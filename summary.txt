=========================================
 PROJECT DIRECTORY STRUCTURE
=========================================

Root directory: D:\Game-Bot

Game-Bot/
    |-- Border.py
    |-- EnemyCircular.py
    |-- EnemyLinear.py
    |-- Game.py
    |-- Player.py
    |-- README.md
    |-- SafeZone.py
    |-- Wall.py
    |-- archive.txt
    |-- config-feedforward.txt
    |-- config.txt
    |-- functions.py
    |-- main.py
    |-- map.txt
    |-- settings.py
    |-- summary.txt
    |-- test.py
|-- __pycache__/

=========================================
 PYTHON FILES CONTENT (.py)
=========================================

--- File: Border.py ---
from functions import *

class Border(pygame.sprite.Sprite):
    """
    Borders

    Attributes
    ----------
    game : Game
        The game that this border is in
    groups : sprite group
        All sprite groups this sprite belongs in
    x : float
        The x coordinate of the border
    y : float
        The y coordinate of the border
    length : int
        The length of the border
    color : int list
        The color of the wall in RGB
    align : int
        The alignment of the border, 0 = horizontal, 1 = vertical



    Methods
    -------
    None

    """
    def __init__(self, game, x, y, length, width, color, align):
        self.groups = game.all_sprites, game.borders
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((length, length), pygame.SRCALPHA, 32)
        self.rect = self.image.get_rect()
        self.x = x
        self.y = y
        self.length = length
        self.width = width
        self.color = color
        self.align = align
        self.rect.x = x
        self.rect.y = y

    def draw(self):
        """
        Draws the borders (separate from sprites)

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        # If the border is horizontal
        if self.align == 0:
            pygame.draw.line(self.game.screen, self.color,
                             [self.x - tile_size/2, self.y],
                             [self.x + tile_size/2, self.y], self.width)
        else:
        # If the border is vertical
            pygame.draw.line(self.game.screen, self.color,
                             [self.x, self.y - tile_size/2],
                             [self.x, self.y + tile_size/2], self.width)



----------------------------------------

--- File: EnemyCircular.py ---
from Wall import *

----------------------------------------

--- File: EnemyLinear.py ---
from EnemyCircular import *

class EnemyLinear(pygame.sprite.Sprite):
    """
    Enemy that travels in a linear path

    Attributes
    ----------
    game : Game
        The game this enemy is in
    groups : sprite group
        All sprite groups this sprite belongs in
    size : int
        The diameter of the circular enemy
    speed : float
        The speed of the enemy
    x : float
        x coordinate of the centre of the circle
    y : float
        y coordinate of the centre of the circle
    xint : float
        The starting x coordinate
    yint : float
        The starting y coordinate
    rect.x : float
        The left bound coordinate of the circle
    rect.y : float
        The upper bound coordinate of the circle
    criticals : float list list
        A list of coordinates that the enemy will loop around
    prevx : float
        The x coordinate of the previous path point
    prevy : float
        The y coordinate of the previous path point
    nextx : float
        The x coordinate of the next path point
    nexty : float
        The y coordinate of the previous path point
    step : int
        The stage in the loop between critical points that the enemy is on
    fill : int list
        The color of the enemy
    border : int list
            The color of the enemy's border

    Methods
    -------
    moves(None) -> None
        Moves the enemy, following its critical track
    update(None) -> None
        Updates the enemy's position after it's moves have been made
    reset(None) -> None
        Moves the enemy back to its original starting position

    """

    def __init__(self, game, size, speed, x, y, criticals, fill, border):
        """
        Constructor to build a player

        Parameters
        ----------
        game : Game
            The game this enemy is in
        size : int
            The diameter of the circular enemy
        speed : float
            The speed of the enemy
        x : float
            Starting x coordinate
        y : float
            Starting y coordinate
        criticals : float list list
            A list of coordinates that the enemy will loop around
        fill : int list
            The color of the enemy
        border : int list
            The color of the enemy's border

	    Returns
        -------
        None

        """
        # Sprites
        self.groups = game.all_sprites, game.enemies
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game

        # Enemy model
        self.image = pygame.Surface((size, size), pygame.SRCALPHA, 32)
        pygame.draw.circle(self.image, border, [int(size/2), int(size/2)], int(size/2))
        pygame.draw.circle(self.image, fill, [int(size/2), int(size/2)], int(size/2) - 4)
        self.rect = self.image.get_rect()
        self.rect.x = x - size/2
        self.rect.y = y - size/2

        self.size = size
        self.speed = speed
        self.x = x
        self.y = y
        self.prevx = x
        self.prevy = y
        self.nextx = criticals[0][0]
        self.nexty = criticals[0][1]
        self.criticals = criticals
        self.step = 0
        self.fill = fill
        self.border = border

    def move(self):
        """
        Moves the enemy, following its critical track

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        if math.hypot(self.nextx - self.x, self.nexty - self.y) <= self.speed:
            self.x = self.nextx
            self.y = self.nexty
            self.prevx = self.nextx
            self.prevy = self.nexty
            if self.step + 1 == len(self.criticals):
                # Loop back to the beginning
                self.step = 0
            else:
                self.step += 1
            self.nextx = self.criticals[self.step][0]
            self.nexty = self.criticals[self.step][1]
        else:
            hyp = math.hypot(self.nextx - self.prevx, self.nexty - self.prevy)
            self.x += (self.nextx - self.prevx) * (self.speed / hyp)
            self.y += (self.nexty - self.prevy) * (self.speed / hyp)

    def update(self):
        """
        Updates the enemy's position after it's moves have been made

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        self.move()
        self.rect.x = self.x - self.size/2
        self.rect.y = self.y - self.size/2

    def reset(self):
        """
        Moves the enemy back to its original starting position

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        self.x = self.criticals[0][0]
        self.y = self.criticals[0][1]
        self.rect.x = self.x - self.size/2
        self.rect.y = self.y - self.size/2


----------------------------------------

--- File: Game.py ---
# File: Game.py

import pygame
import sys
from settings import *
from Wall import Wall
from SafeZone import Zone
from Border import Border
from EnemyLinear import EnemyLinear

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((screen_width, screen_height))
        pygame.display.set_caption(Title)
        self.clock = pygame.time.Clock()
        
        # <<< THAY ĐỔI: Xóa bỏ hình ảnh cho player giỏi nhất >>>
        # self.best_player_image = ... (dòng này đã bị xóa)
        # <<< KẾT THÚC THAY ĐỔI >>>

    def new(self, level):
        self.all_sprites = pygame.sprite.Group()
        self.walls = pygame.sprite.Group()
        self.zones = pygame.sprite.Group()
        self.borders = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()

        self.startx = 0
        self.starty = 0
        self.level = level
        self.target_x = None
        self.target_y = None

        try:
            with open(map_path, 'r', encoding='utf-8') as file:
                data = file.readlines()
        except FileNotFoundError:
            print(f"Error: map file not found at {map_path}")
            self.quit()
            return

        try:
            index = data.index(">>>>>>>>>>>>>>>> Level " + str(self.level) + "\n")
        except ValueError:
            print(f"Error: Level {self.level} not found in map file.")
            self.quit()
            return

        # Đọc map layout
        for y_idx, line in enumerate(data[index + 2 : index + 33]):
            for x_idx, symbol in enumerate(line):
                mapx_grid = x_idx
                mapy_grid = y_idx
                if mapy_grid % 2 != 0 and x_idx % 2 != 0:
                    tile_center_x = (mapx_grid - 1) / 2 * tile_size
                    tile_center_y = (mapy_grid - 1) / 2 * tile_size
                    if symbol == '1':
                        Wall(self, tile_center_x, tile_center_y, tile_size, lightsteelblue)
                    elif symbol in ['g', 'h', 'j', 's']:
                        Zone(self, tile_center_x, tile_center_y, tile_size, palegreen, symbol)
                        if symbol == 's':
                            self.startx = tile_center_x
                            self.starty = tile_center_y
                    elif symbol == '2':
                        if self.target_x is None:
                            self.target_x = tile_center_x + tile_size / 2
                            self.target_y = tile_center_y + tile_size / 2
                elif mapy_grid % 2 == 0 or x_idx % 2 == 0:
                    actual_map_x = mapx_grid * tile_size / 2
                    actual_map_y = mapy_grid * tile_size / 2
                    if symbol == '-' or symbol == '|':
                        align = 0 if symbol == '-' else 1
                        Border(self, actual_map_x, actual_map_y, tile_size, 4, black, align)
        
        if self.target_x is None:
            print("FATAL ERROR: Target '2' not found in map file. AI has no goal.")
            self.quit()

        # Create enemies
        EnemyLinear(self, 22, 4.65, 251, 220, [[251, 220], [549, 220]], blue, midnightblue)
        EnemyLinear(self, 22, 4.65, 549, 260, [[549, 260], [251, 260]], blue, midnightblue)
        EnemyLinear(self, 22, 4.65, 251, 300, [[251, 300], [549, 300]], blue, midnightblue)
        EnemyLinear(self, 22, 4.65, 549, 340, [[549, 340], [251, 340]], blue, midnightblue)
        EnemyLinear(self, 22, 4.65, 251, 380, [[251, 380], [549, 380]], blue, midnightblue)
    
    def draw_map(self):
        for y in range(0, 15):
            for x in range(0, 20):
                fill = lavender
                if (x + y) % 2 == 0:
                    fill = ghostwhite
                pygame.draw.rect(self.screen, fill, [0 + x * tile_size, 0 + y * tile_size, tile_size, tile_size])

    # <<< THAY ĐỔI: Xóa tham số best_player và logic vẽ màu xanh >>>
    def draw(self, players, generation_num, current_fitness, top_fitness):
        self.screen.fill(black)
        self.draw_map()
        
        self.walls.draw(self.screen)
        self.zones.draw(self.screen)
        self.enemies.draw(self.screen)
        for border in self.borders:
            border.draw()

        # Vẽ tất cả player (màu đỏ)
        for player in players:
            self.screen.blit(player.image, player.rect)

        # Vẽ mục tiêu cuối cùng
        if self.target_x is not None:
            pygame.draw.circle(self.screen, (255, 0, 0), (int(self.target_x), int(self.target_y)), 5)

        # Hiển thị thông tin
        font = pygame.font.Font(None, 24)
        text_gen = font.render(f"Generation: {generation_num}", True, black)
        text_players = font.render(f"Players Alive: {len(players)}", True, black)
        text_current_fit = font.render(f"Best Fitness (Gen): {current_fitness:.2f}", True, black)
        text_top_fit = font.render(f"Best Fitness (All Time): {top_fitness:.2f}", True, black)

        self.screen.blit(text_gen, (screen_width - 250, 10))
        self.screen.blit(text_players, (screen_width - 250, 30))
        self.screen.blit(text_current_fit, (screen_width - 250, 50))
        self.screen.blit(text_top_fit, (screen_width - 250, 70))

        pygame.display.update()

    def quit(self):
        pygame.quit()
        sys.exit()
    # <<< KẾT THÚC THAY ĐỔI >>>

----------------------------------------

--- File: Player.py ---
import pygame
import math
from settings import *

class Player(pygame.sprite.Sprite):
    def __init__(self, game, x, y, speed, size, fill, border):
        super().__init__()
        self.game = game
        self.image = pygame.Surface((size, size))
        self.image.fill(border)
        pygame.draw.rect(self.image, fill, [4, 4, size - 8, size - 8])
        self.rect = self.image.get_rect(topleft=(x, y))

        self.speed = speed
        self.size = size
        self.vx = 0
        self.vy = 0

        # Thuộc tính cho NEAT
        self.net = None
        self.genome = None
        self.is_dead = False
        self.time_alive = 0
        
        # <<< THAY ĐỔI: Các thuộc tính cho logic mới >>>
        self.last_pos = self.rect.center
        self.frames_in_start_zone = 0
        
        # 1. Lưới khám phá lãnh thổ mới
        self.visited_grid_cells = set()
        
        # 2. Các tia quét và hướng di chuyển
        self.ray_length = 200
        self.rays = [] # Dùng để vẽ debug
        self.last_raycast_inputs = []
        self.last_move_direction = (0, 0) # (vx, vy)
        # <<< KẾT THÚC THAY ĐỔI >>>

    def _cast_ray(self, angle, obstacles):
        rad_angle = math.radians(angle)
        end_x = self.rect.centerx + self.ray_length * math.cos(rad_angle)
        end_y = self.rect.centery + self.ray_length * math.sin(rad_angle)
        
        self.rays.append(((self.rect.centerx, self.rect.centery), (end_x, end_y)))
        
        closest_dist = self.ray_length
        for obs in obstacles:
            if obs.rect.clipline((self.rect.centerx, self.rect.centery), (end_x, end_y)):
                dist = math.hypot(obs.rect.centerx - self.rect.centerx, obs.rect.centery - self.rect.centery)
                if dist < closest_dist:
                    closest_dist = dist
        
        return closest_dist

    def get_inputs(self):
        inputs = []
        self.rays = [] # Xóa các tia cũ
        
        target_dx = (self.game.target_x - self.rect.centerx) / screen_width
        target_dy = (self.game.target_y - self.rect.centery) / screen_height
        inputs.extend([target_dx, target_dy])
        
        ray_inputs = []
        obstacles = self.game.walls.sprites() + self.game.enemies.sprites()
        for angle in range(0, 360, 45):
            dist = self._cast_ray(angle, obstacles)
            ray_inputs.append(1.0 - (dist / self.ray_length))
        
        inputs.extend(ray_inputs)
        self.last_raycast_inputs = ray_inputs
        return inputs

    def think(self):
        inputs = self.get_inputs()
        outputs = self.net.activate(inputs)
        move_up = outputs[0] > 0.5
        move_down = outputs[1] > 0.5
        move_left = outputs[2] > 0.5
        move_right = outputs[3] > 0.5
        self.vx, self.vy = 0, 0
        if move_up and not move_down: self.vy = -self.speed
        if move_down and not move_up: self.vy = self.speed
        if move_left and not move_right: self.vx = -self.speed
        if move_right and not move_left: self.vx = self.speed
        
        # Lưu lại hướng di chuyển để tính điểm
        self.last_move_direction = (self.vx, self.vy)

    def update(self):
        if self.is_dead:
            return

        self.think()
        
        self.rect.x += self.vx
        self.wall_collision('x')
        self.rect.y += self.vy
        self.wall_collision('y')
        
        self.time_alive += 1

        # <<< THAY ĐỔI: Cập nhật fitness liên tục trong mỗi frame >>>
        self.update_fitness()
        # <<< KẾT THÚC THAY ĐỔI >>>

        # Kiểm tra va chạm kẻ thù
        if pygame.sprite.spritecollide(self, self.game.enemies, False):
            self.genome.fitness -= ENEMY_HIT_PENALTY
            self.is_dead = True
        
        # Kiểm tra thắng
        zones_hit = pygame.sprite.spritecollide(self, self.game.zones, False)
        for zone in zones_hit:
            if zone.type == 'j':
                self.genome.fitness += WIN_REWARD
                self.is_dead = True
                return

    def update_fitness(self):
        """
        Hàm này được gọi MỖI FRAME để cập nhật fitness một cách liên tục.
        """
        # 1. Phạt khi đứng yên
        if self.rect.center == self.last_pos:
            self.genome.fitness -= STAGNATION_PENALTY_WEIGHT
        self.last_pos = self.rect.center

        # 2. Thưởng khi khám phá ô mới
        grid_x = int(self.rect.centerx / tile_size)
        grid_y = int(self.rect.centery / tile_size)
        current_cell = (grid_x, grid_y)
        if current_cell not in self.visited_grid_cells:
            self.visited_grid_cells.add(current_cell)
            self.genome.fitness += NEW_GRID_CELL_REWARD

        # 3. Thưởng khi đi vào không gian mở
        # Chỉ quét tường để tìm không gian mở
        wall_obstacles = self.game.walls.sprites()
        wall_ray_distances = [self._cast_ray(angle, wall_obstacles) for angle in range(0, 360, 45)]
        
        if wall_ray_distances:
            longest_ray_dist = max(wall_ray_distances)
            longest_ray_index = wall_ray_distances.index(longest_ray_dist)
            
            # Tính vector của tia dài nhất
            angle = longest_ray_index * 45
            rad_angle = math.radians(angle)
            open_space_vector = (math.cos(rad_angle), math.sin(rad_angle))
            
            # Tính tích vô hướng để xem hướng di chuyển có "cùng chiều" với không gian mở không
            move_vector = self.last_move_direction
            if move_vector != (0, 0):
                # Chuẩn hóa vector di chuyển
                move_magnitude = math.hypot(move_vector[0], move_vector[1])
                normalized_move = (move_vector[0] / move_magnitude, move_vector[1] / move_magnitude)
                
                # Tích vô hướng (dot product)
                dot_product = open_space_vector[0] * normalized_move[0] + open_space_vector[1] * normalized_move[1]
                
                # Nếu tích vô hướng > 0, nghĩa là đang đi cùng chiều
                if dot_product > 0:
                    reward = dot_product * (longest_ray_dist / self.ray_length) * OPEN_SPACE_REWARD_WEIGHT
                    self.genome.fitness += reward

        # 4. Phạt khi ở trong vùng xuất phát
        is_in_start_zone = False
        zones_hit = pygame.sprite.spritecollide(self, self.game.zones, False)
        for zone in zones_hit:
            if zone.type in ['s', 'g']:
                is_in_start_zone = True
                break
        if is_in_start_zone:
            self.genome.fitness -= START_ZONE_PENALTY_WEIGHT

    def wall_collision(self, direction):
        if direction == 'x':
            hits = pygame.sprite.spritecollide(self, self.game.walls, False)
            if hits:
                if self.vx > 0: self.rect.right = hits[0].rect.left
                if self.vx < 0: self.rect.left = hits[0].rect.right
                self.vx = 0
        if direction == 'y':
            hits = pygame.sprite.spritecollide(self, self.game.walls, False)
            if hits:
                if self.vy > 0: self.rect.bottom = hits[0].rect.top
                if self.vy < 0: self.rect.top = hits[0].rect.bottom
                self.vy = 0

----------------------------------------

--- File: SafeZone.py ---
from Border import *
class Zone(pygame.sprite.Sprite):
    """
    Safe / green zones for checkpoints

    Attributes
    ----------
    x : float
        The x coordinate of the zone
    y : float
        The y coordinate of the zone
    size : int
        The side length of the square zone
    color : int list
        The color of the zone in RGB
    type : char
        The type of green space, g - start, h - checkpoint, j - end, s - starting block



    Methods
    -------
    die(None) -> None
        Deletes the player
    reset(None) -> None
        Increases the number of attempted problems for a specific problem type by one
    reset(None) -> None
        Resets the users stats

    """
    def __init__(self, game, x, y, size, color, type):
        self.groups = game.all_sprites, game.zones
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((size, size))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.type = type

----------------------------------------

--- File: Wall.py ---
from SafeZone import *

class Wall(pygame.sprite.Sprite):
    """
    A wall that serves as an obstacle for the player

    Attributes
    ----------
    game : Game
        The game that this wall is in
    groups : sprite group
        All sprite groups this sprite belongs in
    x : float
        The x coordinate of the wall
    y : float
        The y coordinate of the wall
    size : int
        The side length of the square wall
    color : int list
        The color of the wall in RGB

    Methods
    -------
    None

    """
    def __init__(self, game, x, y, size, color):
        self.groups = game.all_sprites, game.walls
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((size, size))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.size = size
        self.color = color


----------------------------------------

--- File: functions.py ---
# File: functions.py

from settings import *
import os

def python_sort(start, end):
    """
    Sorts the moves file from lowest to highest score with python's built in sort.
    """
    start_time = time.time()
    with open(moves_path, 'r') as file:
        data = file.readlines()
    cluster_lines = data[start : end + 1]

    def get_score_from_line(line):
        try:
            start_index = line.find("Score: ") + 7
            end_index = line.find(" Moves:")
            score_str = line[start_index:end_index].strip()
            return float(score_str)
        except (ValueError, IndexError):
            return -float('inf')

    cluster_lines.sort(key=get_score_from_line)

    data[start : end + 1] = cluster_lines
    with open(moves_path, 'w') as file:
        file.writelines(data)

def calculate_final_score(game, player, cause_of_death):
    """
    Tính điểm cuối cùng cho một player dựa trên công thức mới.
    Score = (1/distance) - penalties
    """
    # 1. Tính khoảng cách đến mục tiêu
    player_center_x = player.rect.x + player.size / 2
    player_center_y = player.rect.y + player.size / 2
    
    distance_to_target = math.hypot(game.target_x - player_center_x, game.target_y - player_center_y)

    # 2. Tính phần thưởng chính (1 / khoảng cách)
    # Thêm 1.0 vào mẫu số để tránh lỗi chia cho 0 và giữ cho điểm không quá lớn
    reward = 150000.0 / (distance_to_target + 1.0)
    
    # 3. Tính toán các hình phạt
    safe_zone_penalty = player.safe_zone_frames * SAFE_ZONE_PENALTY_WEIGHT
    move_penalty = len(player.moves) * MOVE_PENALTY_WEIGHT
    
    # 4. Áp dụng hình phạt dựa trên nguyên nhân chết
    final_score = reward - safe_zone_penalty - move_penalty
    
    if cause_of_death == 'enemy_hit':
        final_score -= ENEMY_HIT_PENALTY
    elif cause_of_death == 'wander_death':
        final_score -= WANDER_DEATH_PENALTY
    elif cause_of_death == 'win':
        final_score += WIN_REWARD

    # In thông tin debug để kiểm tra
    print(f"--- Score Calculation (Gen {game.generation}) ---")
    print(f"  Cause of Death: {cause_of_death}")
    print(f"  Distance to Target: {distance_to_target:.2f}")
    print(f"  Base Reward (1/dist): {reward:.4f}")
    print(f"  Safe Zone Penalty: -{safe_zone_penalty:.2f} ({player.safe_zone_frames} frames)")
    print(f"  Move Penalty: -{move_penalty:.2f} ({len(player.moves)} moves)")
    print(f"  Final Score: {final_score:.4f}")
    print(f"-------------------------")

    return format(final_score, '.5f')

def clear_moves():
    """
    Clears all contents from the moves file
    """
    moves_dir = os.path.dirname(moves_path)
    if not os.path.exists(moves_dir):
        os.makedirs(moves_dir)

    open(moves_path, 'w').close()
    print(f"Cleared previous moves data from: {moves_path}")

----------------------------------------

--- File: main.py ---
# File: main.py

import pygame
import neat
import os
import sys
from Game import Game
from Player import Player
from settings import *

# --- Các hằng số cho việc huấn luyện ---
GENERATION = 0
MAX_FRAMES_PER_GEN = 6000
HIGHEST_FITNESS_SO_FAR = -float('inf')

def eval_genomes(genomes, config):
    global GENERATION, HIGHEST_FITNESS_SO_FAR
    GENERATION += 1
    game = Game()
    game.new(1)
    players = []
    for genome_id, genome in genomes:
        genome.fitness = 0
        net = neat.nn.FeedForwardNetwork.create(genome, config)
        player = Player(game, game.startx, game.starty, 2, 28, red, maroon)
        player.net = net
        player.genome = genome
        players.append(player)
    
    clock = pygame.time.Clock()
    frame_count = 0
    run = True
    while run and len(players) > 0:
        frame_count += 1
        if frame_count > MAX_FRAMES_PER_GEN:
            for player in players:
                player.is_dead = True
            run = False
        
        if DRAW_SCREEN:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

        # Cập nhật game
        for player in players:
            player.update()
        game.enemies.update()

        # Tìm fitness cao nhất và loại bỏ player đã chết
        current_best_fitness = -float('inf')
        for i in range(len(players) - 1, -1, -1):
            player = players[i]
            if player.genome.fitness > current_best_fitness:
                current_best_fitness = player.genome.fitness
            if player.is_dead:
                players.pop(i)
        
        if current_best_fitness > HIGHEST_FITNESS_SO_FAR:
            HIGHEST_FITNESS_SO_FAR = current_best_fitness

        # <<< THAY ĐỔI: Áp dụng Frame Skipping và xóa tham số best_player >>>
        if DRAW_SCREEN and frame_count % FRAME_SKIP == 0:
            game.draw(players, GENERATION, current_best_fitness, HIGHEST_FITNESS_SO_FAR)
            clock.tick(FPS)
        # <<< KẾT THÚC THAY ĐỔI >>>

def run_neat(config_path):
    config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,
                                neat.DefaultSpeciesSet, neat.DefaultStagnation,
                                config_path)
    p = neat.Population(config)
    p.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    p.add_reporter(stats)
    winner = p.run(eval_genomes, 50)
    print('\nBest genome:\n{!s}'.format(winner))

if __name__ == "__main__":
    local_dir = os.path.dirname(__file__)
    config_path = os.path.join(local_dir, 'config-feedforward.txt')
    run_neat(config_path)

----------------------------------------

--- File: settings.py ---
# File: settings.py

import pygame
import time
import sys
import random
import math

pygame.init()

# Kích thước màn hình và tile
tile_size = 40
screen_width = tile_size * 20
screen_height = tile_size * 15

# Đường dẫn file map
map_path = r"D:\Game-Bot\map.txt"

# Cài đặt game
FPS = 60
Title = "NEAT Game Bot"
DRAW_SCREEN = True
FRAME_SKIP = 3

# --- CÁC TRỌNG SỐ VÀ PHẦN THƯỞNG ---
WIN_REWARD = 10000.0
ENEMY_HIT_PENALTY = 50.0
START_ZONE_PENALTY_WEIGHT = 0.8 

# <<< CÁC BIẾN BỊ THIẾU ĐÃ ĐƯỢC THÊM LẠI ĐẦY ĐỦ >>>

# Phạt khi đứng yên (thay vì chết)
STAGNATION_PENALTY_WEIGHT = 0.1

# Thưởng khi khám phá ô mới trên bản đồ
NEW_GRID_CELL_REWARD = 10.0

# Thưởng khi đi theo hướng có không gian mở
OPEN_SPACE_REWARD_WEIGHT = 0.5

# <<< KẾT THÚC PHẦN THÊM VÀO >>>

# Ngưỡng thời gian để coi là trì trệ (không còn dùng để giết player)
STAGNATION_THRESHOLD = 180
# ---------------------------------------------------------

# Colors
red = (255, 0, 0)
black = (0, 0, 0)
lavender = (224, 218, 254)
ghostwhite = (248, 247, 255)
lightsteelblue = (170, 165, 255)
maroon = (127, 0, 0)
palegreen = (158, 242, 155)
blue = (0, 0, 255)
midnightblue = (0, 0, 68)
lime = (53, 247, 0)

----------------------------------------

--- File: test.py ---
import os
import argparse
import tkinter as tk
from tkinter import filedialog

INPUT_PATH = os.getcwd()
OUTPUT_PATH = os.path.join(os.getcwd(), "summary.txt")

DEFAULT_IGNORE_DIRS = {'.git', '_pycache_', 'venv', '.vscode', '.idea', 'node_modules', 'build', 'dist'}
DEFAULT_IGNORE_FILES = {'.DS_Store'}
DEFAULT_IGNORE_EXTENSIONS = {'.pyc', '.log', '.tmp', '.bak', '.swp'}

def generate_project_summary(input_path=INPUT_PATH, output_path=OUTPUT_PATH):
    if not input_path or not os.path.isdir(input_path):
        print(f"Error: Invalid path '{input_path}'")
        return

    project_structure = []
    python_files_content = []
    yaml_files_content = []

    abs_project_path = os.path.abspath(input_path)
    project_root_name = os.path.basename(abs_project_path)

    for dirpath, dirnames, filenames in os.walk(abs_project_path, topdown=True):
        dirnames[:] = [d for d in dirnames if d not in DEFAULT_IGNORE_DIRS]

        relative_dir = os.path.relpath(dirpath, abs_project_path)
        level = relative_dir.count(os.sep) if relative_dir != '.' else 0
        indent = '    ' * level + '|-- '

        if relative_dir == '.':
            project_structure.append(f"{project_root_name}/")
        else:
            if not any(ignored in relative_dir.split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                project_structure.append(f"{indent}{os.path.basename(dirpath)}/")

        sub_indent = '    ' * (level + 1) + '|-- '
        dirnames.sort()
        filenames.sort()

        for filename in filenames:
            if filename in DEFAULT_IGNORE_FILES:
                continue
            if os.path.splitext(filename)[1] in DEFAULT_IGNORE_EXTENSIONS:
                continue

            if not any(ignored in os.path.join(relative_dir, filename).split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                project_structure.append(f"{sub_indent}{filename}")

            if filename.endswith(('.py', '.yaml')):
                file_path = os.path.join(dirpath, filename)
                relative_file_path = os.path.relpath(file_path, abs_project_path)

                if not any(ignored in relative_file_path.split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        if filename.endswith('.py'):
                            python_files_content.append((relative_file_path, content))
                        elif filename.endswith('.yaml'):
                            yaml_files_content.append((relative_file_path, content))

                    except Exception as e:
                        if filename.endswith('.py'):
                            python_files_content.append((relative_file_path, f"Error reading file: {e}"))
                        elif filename.endswith('.yaml'):
                            yaml_files_content.append((relative_file_path, f"Error reading file: {e}"))

    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("=========================================\n")
            outfile.write(" PROJECT DIRECTORY STRUCTURE\n")
            outfile.write("=========================================\n\n")
            outfile.write(f"Root directory: {abs_project_path}\n\n")
            outfile.write('\n'.join(project_structure))
            outfile.write("\n\n=========================================\n")
            outfile.write(" PYTHON FILES CONTENT (.py)\n")
            outfile.write("=========================================\n\n")

            python_files_content.sort(key=lambda item: item[0])

            for rel_path, content in python_files_content:
                outfile.write(f"--- File: {rel_path} ---\n")
                outfile.write(content)
                outfile.write("\n\n----------------------------------------\n\n")

            if yaml_files_content:
                outfile.write("\n\n=========================================\n")
                outfile.write(" YAML FILES CONTENT (.yaml)\n")
                outfile.write("=========================================\n\n")

                yaml_files_content.sort(key=lambda item: item[0])
                for rel_path, content in yaml_files_content:
                    outfile.write(f"--- File: {rel_path} ---\n")
                    outfile.write(content)
                    outfile.write("\n\n----------------------------------------\n\n")

    except Exception as e:
        print(f"Error writing output file: {e}")

if __name__ == "__main__":
    generate_project_summary()

----------------------------------------

