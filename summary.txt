=========================================
 PROJECT DIRECTORY STRUCTURE
=========================================

Root directory: D:\Game-Bot

Game-Bot/
    |-- Border.py
    |-- EnemyCircular.py
    |-- EnemyLinear.py
    |-- Game.py
    |-- Player.py
    |-- README.md
    |-- SafeZone.py
    |-- Wall.py
    |-- archive.txt
    |-- beat.py
    |-- functions.py
    |-- main.py
    |-- map.txt
    |-- moves.txt
    |-- settings.py
    |-- summary.txt
    |-- test.py
|-- __pycache__/

=========================================
 PYTHON FILES CONTENT (.py)
=========================================

--- File: Border.py ---
from functions import *

class Border(pygame.sprite.Sprite):
    """
    Borders

    Attributes
    ----------
    game : Game
        The game that this border is in
    groups : sprite group
        All sprite groups this sprite belongs in
    x : float
        The x coordinate of the border
    y : float
        The y coordinate of the border
    length : int
        The length of the border
    color : int list
        The color of the wall in RGB
    align : int
        The alignment of the border, 0 = horizontal, 1 = vertical



    Methods
    -------
    None

    """
    def __init__(self, game, x, y, length, width, color, align):
        self.groups = game.all_sprites, game.borders
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((length, length), pygame.SRCALPHA, 32)
        self.rect = self.image.get_rect()
        self.x = x
        self.y = y
        self.length = length
        self.width = width
        self.color = color
        self.align = align
        self.rect.x = x
        self.rect.y = y

    def draw(self):
        """
        Draws the borders (separate from sprites)

        Parameters
        ----------
        None

        Returns
        -------
        None

        """

        # If the border is horizontal
        if self.align == 0:
            pygame.draw.line(self.game.screen, self.color,
                             [self.x - tile_size/2, self.y],
                             [self.x + tile_size/2, self.y], self.width)
        else:
        # If the border is vertical
            pygame.draw.line(self.game.screen, self.color,
                             [self.x, self.y - tile_size/2],
                             [self.x, self.y + tile_size/2], self.width)



----------------------------------------

--- File: EnemyCircular.py ---
from Wall import *

----------------------------------------

--- File: EnemyLinear.py ---
from EnemyCircular import *

# Hằng số để chuyển đổi giữa số thực và số nguyên điểm cố định
FIXED_POINT_SCALE = 1000

class EnemyLinear(pygame.sprite.Sprite):
    """
    Enemy that travels in a linear path (Deterministic Version)
    """
    def __init__(self, game, size, speed, x, y, criticals, fill, border):
        self.groups = game.all_sprites, game.enemies
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game

        self.image = pygame.Surface((size, size), pygame.SRCALPHA, 32)
        pygame.draw.circle(self.image, border, [int(size/2), int(size/2)], int(size/2))
        pygame.draw.circle(self.image, fill, [int(size/2), int(size/2)], int(size/2) - 4)
        self.rect = self.image.get_rect()
        
        self.size = size
        
        # --- THAY ĐỔI SANG SỐ HỌC ĐIỂM CỐ ĐỊNH ---
        # Chuyển đổi tất cả giá trị float sang integer để loại bỏ sai số
        self.speed_fixed = int(speed * FIXED_POINT_SCALE)
        self.x_fixed = int(x * FIXED_POINT_SCALE)
        self.y_fixed = int(y * FIXED_POINT_SCALE)
        
        self.criticals_fixed = [[int(p[0] * FIXED_POINT_SCALE), int(p[1] * FIXED_POINT_SCALE)] for p in criticals]
        
        # Cập nhật rect ban đầu
        self.rect.x = (self.x_fixed // FIXED_POINT_SCALE) - size // 2
        self.rect.y = (self.y_fixed // FIXED_POINT_SCALE) - size // 2

        # Khởi tạo trạng thái ban đầu
        self.reset()

    def move(self):
        """
        Moves the enemy using deterministic integer-based math.
        """
        # Tính khoảng cách bằng số nguyên để tránh sai số
        dx = self.nextx_fixed - self.x_fixed
        dy = self.nexty_fixed - self.y_fixed
        dist_sq = dx*dx + dy*dy

        # Nếu đã đến rất gần điểm tiếp theo
        if dist_sq <= self.speed_fixed * self.speed_fixed:
            self.x_fixed = self.nextx_fixed
            self.y_fixed = self.nexty_fixed
            self.prevx_fixed = self.nextx_fixed
            self.prevy_fixed = self.nexty_fixed
            
            if self.step + 1 == len(self.criticals_fixed):
                self.step = 0
            else:
                self.step += 1
                
            self.nextx_fixed = self.criticals_fixed[self.step][0]
            self.nexty_fixed = self.criticals_fixed[self.step][1]
        else:
            # Dùng số nguyên để tính toán di chuyển, đảm bảo tính tất định
            dist = int(math.sqrt(dist_sq))
            if dist == 0: return # Tránh chia cho 0
            
            self.x_fixed += (dx * self.speed_fixed) // dist
            self.y_fixed += (dy * self.speed_fixed) // dist

    def update(self):
        """
        Updates the enemy's position after its moves have been made.
        """
        self.move()
        # Chỉ chuyển đổi về pixel khi cập nhật rect để vẽ
        self.rect.x = (self.x_fixed // FIXED_POINT_SCALE) - self.size // 2
        self.rect.y = (self.y_fixed // FIXED_POINT_SCALE) - self.size // 2

    def reset(self):
        """
        Resets the enemy to its original state completely and deterministically.
        """
        # Reset vị trí về điểm bắt đầu
        self.x_fixed = self.criticals_fixed[0][0]
        self.y_fixed = self.criticals_fixed[0][1]
        
        # Cập nhật rect
        self.rect.x = (self.x_fixed // FIXED_POINT_SCALE) - self.size // 2
        self.rect.y = (self.y_fixed // FIXED_POINT_SCALE) - self.size // 2
        
        # Reset toàn bộ trạng thái đường đi
        self.step = 0
        self.prevx_fixed = self.x_fixed
        self.prevy_fixed = self.y_fixed
        self.nextx_fixed = self.criticals_fixed[0][0]
        self.nexty_fixed = self.criticals_fixed[0][1]

----------------------------------------

--- File: Game.py ---
from Player import * 
from functions import *

class Game:
    """
    The game and functions for setting up
    """

    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((screen_width, screen_height))
        pygame.display.set_caption(Title)
        self.clock = pygame.time.Clock()
        pygame.key.set_repeat(1, 1)
        self.tick = 0
        self.player_count = 100

    def handle_win(self, winning_moves):
        print("Archiving winning moves...")
        try:
            with open(archive_path, 'a', encoding='utf-8') as f:
                f.write(f"Level {self.level} Solution:\n")
                f.write(winning_moves + "\n\n")
            print(f"Successfully saved winning moves to {archive_path}")
            print("You can now run beat.py to watch the replay.")
        except Exception as e:
            print(f"Error saving to archive.txt: {e}")

    def new(self, level):
        self.all_sprites = pygame.sprite.Group()
        self.players = pygame.sprite.Group()
        self.player_list = []
        self.walls = pygame.sprite.Group()
        self.zones = pygame.sprite.Group()
        self.borders = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()

        self.startx = 0
        self.starty = 0
        self.checkx = 0
        self.checky = 0
        self.level = level
        self.target_x = None
        self.target_y = None

        self.top_5_moves = []
        self.best_move_for_rewind = ''
        self.best_move_num_for_rewind = 0
        
        self.generation = 0
        self.rewind = False

        try:
            with open(map_path, 'r', encoding='utf-8') as file:
                data = file.readlines()
        except FileNotFoundError:
            print(f"Error: map file not found at {map_path}")
            self.quit()
            return

        # Sử dụng logic tìm kiếm linh hoạt để tránh lỗi vặt
        index = -1
        level_header = f"Level {self.level}"
        for i, line in enumerate(data):
            if level_header in line:
                index = i
                break
        
        if index == -1:
            print(f"Error: Level {self.level} not found in map file.")
            self.quit()
            return

        # LOGIC ĐỌC MAP GỐC CỦA BẠN
        for y in range(index + 2, index + 33):
            for x in range(0, 41):
                symbol = data[y][x]
                mapx_grid = x
                mapy_grid = (y - 2 - index)
                actual_map_x = mapx_grid * tile_size / 2
                actual_map_y = mapy_grid * tile_size / 2
                if mapy_grid % 2 == 0 or mapx_grid % 2 == 0:
                    if symbol == '-' or symbol == '|':
                        align = 0 if symbol == '-' else 1
                        Border(self, actual_map_x, actual_map_y, tile_size, 4, black, align)
                else:
                    tile_center_x = (mapx_grid - 1) / 2 * tile_size
                    tile_center_y = (mapy_grid - 1) / 2 * tile_size
                    if symbol == '1':
                        Wall(self, tile_center_x, tile_center_y, tile_size, lightsteelblue)
                    elif symbol in ['g', 'h', 'j', 's']:
                        Zone(self, tile_center_x, tile_center_y, tile_size, palegreen, symbol)
                        if symbol == 's':
                            self.startx = tile_center_x
                            self.starty = tile_center_y
                            self.checkx = self.startx
                            self.checky = self.starty
                    elif symbol == '2':
                        if self.target_x is None:
                            self.target_x = tile_center_x + tile_size / 2
                            self.target_y = tile_center_y + tile_size / 2
                            print(f"Target '2' found at coordinates: ({self.target_x}, {self.target_y})")

        if self.target_x is None:
            # Thêm ký tự '2' vào map.txt nếu bạn gặp lỗi này
            print("FATAL ERROR: Target '2' not found in map file. AI has no goal.")
            self.quit()
            return

        # TẠO KẺ ĐỊCH HARD-CODE NHƯ BAN ĐẦU
        EnemyLinear(self, 22, 4.65, 251, 220, [[251, 220], [549, 220]], blue, midnightblue)
        EnemyLinear(self, 22, 4.65, 549, 260, [[549, 260], [251, 260]], blue, midnightblue)
        '''
        EnemyLinear(self, 22, 4.65, 251, 300, [[251, 300], [549, 300]], blue, midnightblue)
        
        EnemyLinear(self, 22, 4.65, 549, 340, [[549, 340], [251, 340]], blue, midnightblue)
        EnemyLinear(self, 22, 4.65, 251, 380, [[251, 380], [549, 380]], blue, midnightblue)
        '''
    # ... (tất cả các hàm còn lại của Game.py giữ nguyên như file gốc của bạn) ...
    def create_initial_players(self):
        self.player_list = []
        for i in range(self.player_count):
            player = Player(self, 'random', self.startx, self.starty, 2, 28, red, maroon)
            self.player_list.append(player)
        print(f"Generation {self.generation}: Created {len(self.player_list)} initial random players.")

    def new_generation_players(self):
        self.player_list = []
        if not self.top_5_moves:
            print(f"Warning: No best moves found from previous generation. Creating random players.")
            self.create_initial_players()
            return

        players_per_move = self.player_count // len(self.top_5_moves)

        for i in range(self.player_count):
            move_index = min(i // players_per_move, len(self.top_5_moves) - 1)
            inherited_moves = self.top_5_moves[move_index]
            
            player = Player(self, 'hybrid', self.checkx, self.checky, 2, 28, red, maroon)
            player.inherited_moves = inherited_moves
            self.player_list.append(player)
            
        print(f"Generation {self.generation}: Created {len(self.player_list)} players inheriting from top {len(self.top_5_moves)} moves.")

    def end_gen(self):
        print(f"Ending Generation {self.generation}...")
        with open(moves_path, 'a', encoding='utf-8') as file:
            file.write("END OF GENERATION " + str(self.generation) + "\n")

        start_line_index = self.generation * (self.player_count + 1)
        end_line_index = start_line_index + self.player_count - 1
        
        try:
            python_sort(start_line_index, end_line_index)
        except IndexError:
            self.top_5_moves = []
            self.best_move_for_rewind = ''
            self.best_move_num_for_rewind = 0
            return

        with open(moves_path, 'r', encoding='utf-8') as file:
            data = file.readlines()

        num_top_moves = 5
        top_moves_start_index = max(start_line_index, end_line_index - num_top_moves + 1)
        top_moves_lines = data[top_moves_start_index : end_line_index + 1]
        top_moves_lines.reverse()

        self.top_5_moves = []
        for line in top_moves_lines:
            try:
                moves_start_index = line.find("Moves: ")
                if moves_start_index != -1:
                    full_moves = line[moves_start_index + len("Moves: "):].strip()
                    trimmed_moves = full_moves[:-10] if len(full_moves) > 10 else full_moves
                    self.top_5_moves.append(trimmed_moves)
            except Exception as e:
                print(f"Error parsing a best move line: {e}")

        if not self.top_5_moves:
            print("Warning: Could not extract any best moves for the next generation.")
            self.best_move_for_rewind = ''
            self.best_move_num_for_rewind = 0
        else:
            self.best_move_for_rewind = self.top_5_moves[0]
            self.best_move_num_for_rewind = len(self.best_move_for_rewind)
            print(f"Extracted top {len(self.top_5_moves)} moves for next generation.")
            print(f"Best move for rewinder has {self.best_move_num_for_rewind} steps.")

        self.generation += 1
        self.rewind = True
        print(f"Starting Generation {self.generation} rewind phase.")

        self.rewinder = Player(self, 'random', self.startx, self.starty, 2, 28, lime, black)
        self.player_list.append(self.rewinder)

        for enemy in self.enemies:
            enemy.reset()

    def run(self):
        self.run = True
        while self.run:
            self.dt = self.clock.tick(FPS) / 1000
            self.events()
            if not self.rewind and len(self.player_list) == 0:
                self.end_gen()
            elif self.rewind and len(self.player_list) == 0:
                self.rewind = False
                self.tick = 0
                self.new_generation_players()
            for i in range(zoom):
                self.update()
            self.draw()

    def update(self):
        self.all_sprites.update()

    def draw_map(self):
        for y in range(0, 15):
            for x in range(0, 20):
                fill = lavender if (x + y) % 2 != 0 else ghostwhite
                pygame.draw.rect(self.screen, fill, [x * tile_size, y * tile_size, tile_size, tile_size])

    def draw(self):
        self.screen.fill(black)
        self.draw_map()
        self.all_sprites.draw(self.screen)
        for border in self.borders:
            border.draw()
        font = pygame.font.Font(None, 24)
        text_gen = font.render(f"Generation: {self.generation}", True, black)
        text_players = font.render(f"Players Alive: {len(self.player_list) - (1 if self.rewind else 0)}", True, black)
        self.screen.blit(text_gen, (screen_width - 180, 10))
        self.screen.blit(text_players, (screen_width - 180, 30))
        pygame.display.update()

    def events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.quit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.quit()

    def quit(self):
        pygame.quit()
        sys.exit()

----------------------------------------

--- File: Player.py ---
from EnemyLinear import *

class Player(pygame.sprite.Sprite):
    """
    The player that moves to complete levels
    """

    def __init__(self, game, control, x, y, speed, size, fill, border):
        self.groups = game.all_sprites, game.players
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((size, size))
        self.image.fill(border)
        pygame.draw.rect(self.image, fill, [4, 4, size - 8, size - 8])
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

        self.vx = 0
        self.vy = 0
        self.direction = 0

        self.control = control
        self.speed = speed
        self.size = size
        self.fill = fill
        self.border = border

        # AI related attributes
        self.moves = ''
        self.changes = 0
        self.change_limit = 70
        self.inherited_moves = ''
        self.current_move_index = 0
        self.hit = False
        self.score_calculated = False
        
        # Theo dõi số frame trong vùng an toàn
        self.safe_zone_frames = 0

    def move(self, control):
        if control == 'keys':
            self.vx = 0
            self.vy = 0
            direction = 0
            keys = pygame.key.get_pressed()
            if keys[pygame.K_s] or keys[pygame.K_DOWN]:
                self.vy = self.speed
                direction = 5
            if keys[pygame.K_w] or keys[pygame.K_UP]:
                self.vy = -self.speed
                direction = 1
            if keys[pygame.K_a] or keys[pygame.K_LEFT]:
                self.vx = -self.speed
                if direction == 5: direction = 6
                elif direction == 1: direction = 8
                else: direction = 7
            if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
                self.vx = self.speed
                if direction == 5: direction = 4
                elif direction == 1: direction = 2
                else: direction = 3
            self.direction = direction
            self.moves += str(self.direction)

        elif control == 'random':
            direction = random.randint(0, 8)
            change_chance = random.randint(0, 10)
            
            if change_chance == 0:
                self.changes += 1
                self.vx = 0
                self.vy = 0
                if direction in [4, 5, 6]: self.vy = self.speed
                if direction in [8, 1, 2]: self.vy = -self.speed
                if direction in [6, 7, 8]: self.vx = -self.speed
                if direction in [2, 3, 4]: self.vx = self.speed
                self.direction = direction
            self.moves += str(self.direction)

    def read_move(self, direction):
        self.vx = 0
        self.vy = 0
        if direction in [4, 5, 6]: self.vy = self.speed
        if direction in [8, 1, 2]: self.vy = -self.speed
        if direction in [6, 7, 8]: self.vx = -self.speed
        if direction in [2, 3, 4]: self.vx = self.speed

    def update(self):
        # Kiểm tra chết do đi luẩn quẩn
        if self.control in ['random', 'hybrid'] and self.changes > self.change_limit:
            self.end_moves(cause_of_death='wander_death')
            return

        # Logic di chuyển
        if self.game.rewind:
            if self.fill == lime:
                if self.game.tick < self.game.best_move_num_for_rewind:
                    self.read_move(int(self.game.best_move_for_rewind[self.game.tick]))
                    self.game.tick += 1
                else:
                    self.game.rewind = False
                    self.game.tick = 0
                    self.game.checkx = self.rect.x
                    self.game.checky = self.rect.y
                    self.game.new_generation_players()
                    self.die()
                    return
        else:
            if self.control == 'hybrid':
                if self.current_move_index < len(self.inherited_moves):
                    direction = int(self.inherited_moves[self.current_move_index])
                    self.read_move(direction)
                    self.current_move_index += 1
                    self.moves += str(direction)
                else:
                    self.move('random')
            elif self.control == 'random':
                self.move('random')

        # Áp dụng di chuyển và va chạm tường
        self.rect.x += self.vx
        self.wall_collision('x')
        self.rect.y += self.vy
        self.wall_collision('y')

        # Logic phạt và kiểm tra thắng
        if not self.game.rewind:
            zones_hit = pygame.sprite.spritecollide(self, self.game.zones, False)
            in_safe_zone = False
            for zone in zones_hit:
                if zone.type == 'j':
                    self.end_moves(cause_of_death='win')
                    return
                if zone.type in ['s', 'g', 'h']:
                    in_safe_zone = True
            
            if in_safe_zone:
                self.safe_zone_frames += 1

        # Kiểm tra va chạm enemy
        self.enemy_collision()

    def wall_collision(self, direction):
        if direction == 'x':
            wall_hit = pygame.sprite.spritecollide(self, self.game.walls, False)
            if wall_hit:
                if self.vx > 0: self.rect.right = wall_hit[0].rect.left
                if self.vx < 0: self.rect.left = wall_hit[0].rect.right
                self.vx = 0
        if direction == 'y':
            wall_hit = pygame.sprite.spritecollide(self, self.game.walls, False)
            if wall_hit:
                if self.vy > 0: self.rect.bottom = wall_hit[0].rect.top
                if self.vy < 0: self.rect.top = wall_hit[0].rect.bottom
                self.vy = 0

    def enemy_collision(self):
        enemy_hit = pygame.sprite.spritecollide(self, self.game.enemies, False)
        if enemy_hit:
            self.hit = True
            self.end_moves(cause_of_death='enemy_hit')

    def respawn(self):
        self.rect.x = self.game.startx
        self.rect.y = self.game.starty
        self.vx = 0
        self.vy = 0
        self.moves = ''
        self.changes = 0
        self.hit = False
        self.score_calculated = False
        self.safe_zone_frames = 0

    def die(self):
        self.game.all_sprites.remove(self)
        self.game.players.remove(self)
        if self in self.game.player_list:
            self.game.player_list.remove(self)

    def end_moves(self, cause_of_death):
        if self.score_calculated:
            return
        self.score_calculated = True

        score = calculate_final_score(self.game, self, cause_of_death)

        with open(moves_path, 'a') as file:
            file.write(f"Score: {score} Moves: {self.moves}\n")
        
        # <<< THAY ĐỔI: XỬ LÝ KHI CHIẾN THẮNG >>>
        if cause_of_death == 'win':
            print(f"AI Successfully Completed Level {self.game.level}!")
            self.game.handle_win(self.moves) # Gọi hàm xử lý chiến thắng
            self.game.run = False
        # <<< KẾT THÚC THAY ĐỔI >>>

        self.die()

----------------------------------------

--- File: SafeZone.py ---
from Border import *
class Zone(pygame.sprite.Sprite):
    """
    Safe / green zones for checkpoints

    Attributes
    ----------
    x : float
        The x coordinate of the zone
    y : float
        The y coordinate of the zone
    size : int
        The side length of the square zone
    color : int list
        The color of the zone in RGB
    type : char
        The type of green space, g - start, h - checkpoint, j - end, s - starting block



    Methods
    -------
    die(None) -> None
        Deletes the player
    reset(None) -> None
        Increases the number of attempted problems for a specific problem type by one
    reset(None) -> None
        Resets the users stats

    """
    def __init__(self, game, x, y, size, color, type):
        self.groups = game.all_sprites, game.zones
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((size, size))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.type = type

----------------------------------------

--- File: Wall.py ---
from SafeZone import *

class Wall(pygame.sprite.Sprite):
    """
    A wall that serves as an obstacle for the player

    Attributes
    ----------
    game : Game
        The game that this wall is in
    groups : sprite group
        All sprite groups this sprite belongs in
    x : float
        The x coordinate of the wall
    y : float
        The y coordinate of the wall
    size : int
        The side length of the square wall
    color : int list
        The color of the wall in RGB

    Methods
    -------
    None

    """
    def __init__(self, game, x, y, size, color):
        self.groups = game.all_sprites, game.walls
        pygame.sprite.Sprite.__init__(self, self.groups)
        self.game = game
        self.image = pygame.Surface((size, size))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.size = size
        self.color = color


----------------------------------------

--- File: beat.py ---
import pygame
import sys
from Game import Game
from Player import Player
from settings import *
import random
# This standalone file reads the last solution from archive.txt and replays it.

def get_last_solution_from_archive():
    """
    Reads archive.txt and returns the last recorded move sequence.
    """
    try:
        with open(archive_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        for i in range(len(lines) - 1, -1, -1):
            line = lines[i].strip()
            if line.isdigit():
                print(f"Found solution with {len(line)} moves in archive.txt")
                return line
        
        print("Error: No valid move sequence found in archive.txt")
        return None
    except FileNotFoundError:
        print(f"Error: archive.txt not found at {archive_path}")
        return None
    except Exception as e:
        print(f"An error occurred while reading archive.txt: {e}")
        return None

def run_replay(moves, level):
    """
    Initializes a game and replays the provided moves.
    """
    if not moves:
        print("Cannot start replay without a move sequence.")
        return

    pygame.init()
    game = Game()
    game.new(level)

    player = Player(game, 'replay', game.startx, game.starty, 2, 28, lime, black)
    
    for p in game.player_list:
        p.die()
    game.player_list = [player]
    
    clock = pygame.time.Clock()
    running = True
    move_index = 0
    
    print("--- Starting Replay ---")
    
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False

        # <<< PHẦN CẬP NHẬT QUAN TRỌNG >>>
        # Vòng lặp này đảm bảo replay chạy ở cùng tốc độ logic với training
        for _ in range(zoom):
            # Nạp một bước đi cho mỗi lần cập nhật logic
            if move_index < len(moves):
                direction = int(moves[move_index])
                player.read_move(direction)
                move_index += 1
            else:
                # Khi hết bước đi, giữ người chơi đứng yên
                player.read_move(0) 

            # Cập nhật logic game
            game.all_sprites.update()
        # <<< KẾT THÚC CẬP NHẬT >>>

        # Vẽ mọi thứ ra màn hình (chỉ 1 lần sau khi đã cập nhật logic 'zoom' lần)
        game.draw()
        
        # Hiển thị thông tin replay
        font = pygame.font.Font(None, 28)
        text_replay = font.render("REPLAY MODE", True, red)
        text_step = font.render(f"Step: {move_index}/{len(moves)}", True, black)
        game.screen.blit(text_replay, (10, 10))
        game.screen.blit(text_step, (10, 40))

        pygame.display.flip()
        clock.tick(FPS)

    print("--- Replay Finished ---")
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    random.seed(42)
    LEVEL_TO_BEAT = 1 
    winning_moves = get_last_solution_from_archive()
    run_replay(winning_moves, LEVEL_TO_BEAT)

----------------------------------------

--- File: functions.py ---
from settings import *
import os
import time

def python_sort(start, end):
    """
    Sorts the moves file from lowest to highest score using Python's built-in sort.
    """
    start_time = time.time()
    # THÊM encoding='utf-8'
    with open(moves_path, 'r', encoding='utf-8') as file:
        data = file.readlines()
    cluster_lines = data[start : end + 1]

    def get_score_from_line(line):
        try:
            start_index = line.find("Score: ") + 7
            end_index = line.find(" Moves:")
            score_str = line[start_index:end_index].strip()
            return float(score_str)
        except (ValueError, IndexError):
            return -float('inf')

    cluster_lines.sort(key=get_score_from_line)

    data[start : end + 1] = cluster_lines
    # THÊM encoding='utf-8'
    with open(moves_path, 'w', encoding='utf-8') as file:
        file.writelines(data)

def calculate_final_score(game, player, cause_of_death):
    """
    Calculates the final score for a player based on the new formula.
    """
    player_center_x = player.rect.x + player.size / 2
    player_center_y = player.rect.y + player.size / 2
    distance_to_target = math.hypot(game.target_x - player_center_x, game.target_y - player_center_y)
    reward = 150000.0 / (distance_to_target + 1.0)
    
    safe_zone_penalty = player.safe_zone_frames * SAFE_ZONE_PENALTY_WEIGHT
    move_penalty = len(player.moves) * MOVE_PENALTY_WEIGHT
    final_score = reward - safe_zone_penalty - move_penalty
    
    if cause_of_death == 'enemy_hit':
        final_score -= ENEMY_HIT_PENALTY
    elif cause_of_death == 'wander_death':
        final_score -= WANDER_DEATH_PENALTY
    elif cause_of_death == 'win':
        final_score += WIN_REWARD

    return format(final_score, '.5f')

def clear_moves():
    """
    Clears all content from the moves file.
    """
    moves_dir = os.path.dirname(moves_path)
    if not os.path.exists(moves_dir):
        os.makedirs(moves_dir)

    # THÊM encoding='utf-8'
    open(moves_path, 'w', encoding='utf-8').close()
    print(f"Cleared previous moves data from: {moves_path}")

from settings import *
import os
import time

def python_sort(start, end):
    """
    Sorts the moves file from lowest to highest score using Python's built-in sort.
    """
    start_time = time.time()
    with open(moves_path, 'r', encoding='utf-8') as file:
        data = file.readlines()
    cluster_lines = data[start : end + 1]

    def get_score_from_line(line):
        try:
            start_index = line.find("Score: ") + 7
            end_index = line.find(" Moves:")
            score_str = line[start_index:end_index].strip()
            return float(score_str)
        except (ValueError, IndexError):
            return -float('inf')

    cluster_lines.sort(key=get_score_from_line)

    data[start : end + 1] = cluster_lines
    with open(moves_path, 'w', encoding='utf-8') as file:
        file.writelines(data)

def calculate_final_score(game, player, cause_of_death):
    """
    Calculates the final score for a player based on the new formula.
    """
    player_center_x = player.rect.x + player.size / 2
    player_center_y = player.rect.y + player.size / 2
    distance_to_target = math.hypot(game.target_x - player_center_x, game.target_y - player_center_y)
    reward = (distance_to_target + 1.0)*10000
    
    safe_zone_penalty = player.safe_zone_frames * SAFE_ZONE_PENALTY_WEIGHT
    move_penalty = len(player.moves) * MOVE_PENALTY_WEIGHT
    final_score =  - safe_zone_penalty - move_penalty - reward
    
    if cause_of_death == 'enemy_hit':
        final_score -= ENEMY_HIT_PENALTY
    elif cause_of_death == 'wander_death':
        final_score -= WANDER_DEATH_PENALTY
    elif cause_of_death == 'win':
        final_score += WIN_REWARD

    return format(final_score, '.5f')

def clear_moves():
    """
    Clears all content from the moves file.
    """
    moves_dir = os.path.dirname(moves_path)
    if not os.path.exists(moves_dir):
        os.makedirs(moves_dir)

    open(moves_path, 'w', encoding='utf-8').close()
    print(f"Cleared previous moves data from: {moves_path}")

# <<< HÀM MỚI >>>
def clear_archive():
    """
    Clears all content from the archive file to ensure a clean run.
    """
    # Đảm bảo file tồn tại trước khi xóa nội dung
    try:
        open(archive_path, 'w', encoding='utf-8').close()
        print(f"Cleared previous archive data from: {archive_path}")
    except Exception as e:
        print(f"Could not clear archive file (it might not exist yet): {e}")

----------------------------------------

--- File: main.py ---
import os
import argparse
# import tkinter as tk # Not needed for AI training run
# from tkinter import filedialog # Not needed for AI training run

# Import your game components
from Game import Game
from functions import * # Make sure these are properly imported
from settings import *
# This main.py is specifically for running the AI training.
# The original main.py to generate summary.txt should be kept separate or renamed.

# Define paths (ensure these match settings.py or are consistent)
# These should ideally be read from settings.py or passed through a config
# For simplicity, if settings.py already defines them, we don't need to redefine here
# Assuming settings.py is correctly setting map_path and moves_path

if __name__ == "__main__":
    random.seed(12345)
    print("Clearing previous moves data...")
    clear_moves()
    clear_archive()
    # Create an instance of the game
    game = Game()
    
    # Initialize the game with level 1
    # This will load the map, create enemies, etc.
    game.new(1) # Assuming you want to train on Level 1

    # Create the initial generation of players
    game.create_initial_players()

    # Start the game loop
    print(f"Starting AI training for 'Game khó nhất thế giới' on Level {game.level}...")
    game.run()

    print("AI training finished.")
    # You might want to print the final best_moves here or load it from moves.txt
    if game.run == False:
        print(f"Level was passed after {game.generation} generations!")
    else:
        print(f"Game ended after {game.generation} generations.")
    
    # Optionally, read and print the overall best move from the last generation
    try:
        # THÊM encoding='utf-8'
        with open(moves_path, 'r', encoding='utf-8') as file:
            data = file.readlines()
            if data:
                # Find the last "END OF GENERATION" marker
                last_gen_end_index = -1
                for i in range(len(data) - 1, -1, -1):
                    if "END OF GENERATION" in data[i]:
                        last_gen_end_index = i
                        break
                
                if last_gen_end_index != -1:
                    # The sorted block for the last generation is *before* this marker
                    # The best move will be the last line of the sorted block
                    # Need to infer start_line_index for the *last completed* generation
                    # which is game.generation - 1
                    
                    # Assuming the last recorded generation is game.generation - 1
                    # and it has (player_count + 1) lines per block.
                    # Best move is at start_line_index + player_count - 1
                    
                    last_completed_gen_idx = game.generation - 1
                    if last_completed_gen_idx >= 0:
                        start_line_of_last_gen_moves = last_completed_gen_idx * (game.player_count + 1)
                        best_move_line_idx = start_line_of_last_gen_moves + game.player_count - 1
                        
                        if best_move_line_idx < len(data):
                            best_move_line = data[best_move_line_idx]
                            moves_start_index = best_move_line.find("Moves: ")
                            if moves_start_index != -1:
                                final_best_moves = best_move_line[moves_start_index + len("Moves: "):].strip()
                                print(f"\nOverall best moves found: {final_best_moves}")
                            else:
                                print("\nCould not find 'Moves:' in the overall best move line.")
                        else:
                            print("\nNo recorded best moves for the last completed generation.")
                    else:
                        print("\nNo generations completed yet.")
                else:
                    print("\nNo 'END OF GENERATION' markers found in moves.txt.")
            else:
                print("\nmoves.txt is empty.")
    except FileNotFoundError:
        print(f"moves.txt not found at {moves_path}")
    except Exception as e:
        print(f"Error reading moves.txt for final best move: {e}")

----------------------------------------

--- File: settings.py ---
import pygame
import time
import sys
import random
import math

pygame.init()

# size of the square tiles that make up the map
tile_size = 40
screen_width = tile_size * 20
screen_height = tile_size * 15

# true if the game is running
run = True

# File path for data files
map_path = r"D:\Game-Bot\map.txt"
moves_path = r"D:\Game-Bot\moves.txt"
archive_path = r"D:\Game-Bot\archive.txt" # <<< DÒNG MỚI

# Game settings
FPS = 60
zoom = 1
Title = "Hùng Ngu"


# Trọng số phạt cho mỗi frame ở trong vùng an toàn (g, s, h)
SAFE_ZONE_PENALTY_WEIGHT = 2.0
# Trọng số phạt cho mỗi bước di chuyển
MOVE_PENALTY_WEIGHT = 0.5
# Điểm phạt khi va chạm kẻ thù
ENEMY_HIT_PENALTY = 0.0
# Điểm phạt khi đi luẩn quẩn đến chết (nặng hơn va chạm enemy)
WANDER_DEATH_PENALTY = 400.0
# Điểm thưởng cực lớn khi chiến thắng
WIN_REWARD = 10000.0
# ---------------------------------------------------------

# Colors
red = (255, 0, 0)
black = (0, 0, 0)
lavender = (224, 218, 254)
ghostwhite = (248, 247, 255)
lightsteelblue = (170, 165, 255)
maroon = (127, 0, 0)
palegreen = (158, 242, 155)
blue = (0, 0, 255)
midnightblue = (0, 0, 68)
lime = (53, 247, 0)

----------------------------------------

--- File: test.py ---
import os
import argparse
import tkinter as tk
from tkinter import filedialog

INPUT_PATH = os.getcwd()
OUTPUT_PATH = os.path.join(os.getcwd(), "summary.txt")

DEFAULT_IGNORE_DIRS = {'.git', '_pycache_', 'venv', '.vscode', '.idea', 'node_modules', 'build', 'dist'}
DEFAULT_IGNORE_FILES = {'.DS_Store'}
DEFAULT_IGNORE_EXTENSIONS = {'.pyc', '.log', '.tmp', '.bak', '.swp'}

def generate_project_summary(input_path=INPUT_PATH, output_path=OUTPUT_PATH):
    if not input_path or not os.path.isdir(input_path):
        print(f"Error: Invalid path '{input_path}'")
        return

    project_structure = []
    python_files_content = []
    yaml_files_content = []

    abs_project_path = os.path.abspath(input_path)
    project_root_name = os.path.basename(abs_project_path)

    for dirpath, dirnames, filenames in os.walk(abs_project_path, topdown=True):
        dirnames[:] = [d for d in dirnames if d not in DEFAULT_IGNORE_DIRS]

        relative_dir = os.path.relpath(dirpath, abs_project_path)
        level = relative_dir.count(os.sep) if relative_dir != '.' else 0
        indent = '    ' * level + '|-- '

        if relative_dir == '.':
            project_structure.append(f"{project_root_name}/")
        else:
            if not any(ignored in relative_dir.split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                project_structure.append(f"{indent}{os.path.basename(dirpath)}/")

        sub_indent = '    ' * (level + 1) + '|-- '
        dirnames.sort()
        filenames.sort()

        for filename in filenames:
            if filename in DEFAULT_IGNORE_FILES:
                continue
            if os.path.splitext(filename)[1] in DEFAULT_IGNORE_EXTENSIONS:
                continue

            if not any(ignored in os.path.join(relative_dir, filename).split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                project_structure.append(f"{sub_indent}{filename}")

            if filename.endswith(('.py', '.yaml')):
                file_path = os.path.join(dirpath, filename)
                relative_file_path = os.path.relpath(file_path, abs_project_path)

                if not any(ignored in relative_file_path.split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        if filename.endswith('.py'):
                            python_files_content.append((relative_file_path, content))
                        elif filename.endswith('.yaml'):
                            yaml_files_content.append((relative_file_path, content))

                    except Exception as e:
                        if filename.endswith('.py'):
                            python_files_content.append((relative_file_path, f"Error reading file: {e}"))
                        elif filename.endswith('.yaml'):
                            yaml_files_content.append((relative_file_path, f"Error reading file: {e}"))

    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("=========================================\n")
            outfile.write(" PROJECT DIRECTORY STRUCTURE\n")
            outfile.write("=========================================\n\n")
            outfile.write(f"Root directory: {abs_project_path}\n\n")
            outfile.write('\n'.join(project_structure))
            outfile.write("\n\n=========================================\n")
            outfile.write(" PYTHON FILES CONTENT (.py)\n")
            outfile.write("=========================================\n\n")

            python_files_content.sort(key=lambda item: item[0])

            for rel_path, content in python_files_content:
                outfile.write(f"--- File: {rel_path} ---\n")
                outfile.write(content)
                outfile.write("\n\n----------------------------------------\n\n")

            if yaml_files_content:
                outfile.write("\n\n=========================================\n")
                outfile.write(" YAML FILES CONTENT (.yaml)\n")
                outfile.write("=========================================\n\n")

                yaml_files_content.sort(key=lambda item: item[0])
                for rel_path, content in yaml_files_content:
                    outfile.write(f"--- File: {rel_path} ---\n")
                    outfile.write(content)
                    outfile.write("\n\n----------------------------------------\n\n")

    except Exception as e:
        print(f"Error writing output file: {e}")

if __name__ == "__main__":
    generate_project_summary()

----------------------------------------

