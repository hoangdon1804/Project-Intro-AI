=========================================
 PROJECT DIRECTORY STRUCTURE
=========================================

Root directory: D:\PRJqq

PRJqq/
    |-- archivement.txt
    |-- c.txt
    |-- level_manager.py
    |-- main.py
    |-- replay.py
    |-- script.js
    |-- settings.py
    |-- sprites.py
    |-- summary.txt
    |-- test.py
    |-- train.py
|-- __pycache__/

=========================================
 PYTHON FILES CONTENT (.py)
=========================================

--- File: level_manager.py ---
import pygame
from settings import *

class LevelManager:
    @staticmethod
    def get_config(lvl):
        config = {
            "player_pos": (160, 335),
            "enemies": [], "coins": [], "walls_pts": [], "grid_cells": [],
            "finish_rect": pygame.Rect(0,0,0,0), "checkpoints": [], "coins_req": 0
        }

        if lvl == 0:
            config["enemies"] = [[325,325,6,0], [325,425,6,0], [775,275,-6,0], [775,375,-6,0]]
            config["walls_pts"] = [(250,450), (250,200), (100,200), (100,500), (350,500), (350,450), (800,450), (800,250), (850,250), (850,500), (1000,500), (1000,200), (750,200), (750,250), (300,250), (300,450)]
            config["finish_rect"] = pygame.Rect(850, 200, 150, 300)
            # Grid Level 0
            for x in range(350, 800, 100): config["grid_cells"] += [(x,250), (x,350)]
            for x in range(300, 750, 100): config["grid_cells"] += [(x,300), (x,400)]
            config["grid_cells"] += [(250,450), (800,200)]

        elif lvl == 1:
            config["enemies"] = [[x, 226, 0, 6] for x in range(275, 875, 100)] + [[x, 474, 0, -6] for x in range(325, 925, 100)]
            config["walls_pts"] = [(250,400), (100,400), (100,300), (250,300), (250,200), (850,200), (850,300), (1000,300), (1000,400), (850,400), (850,500), (250,500)]
            config["finish_rect"] = pygame.Rect(850, 300, 150, 100)
            config["coins"] = [[550, 350]]; config["coins_req"] = 1
            # Grid Level 1
            for x in range(300, 850, 100): config["grid_cells"] += [(x, 200), (x, 300), (x, 400)]
            for x in range(250, 800, 100): config["grid_cells"] += [(x, 250), (x, 350), (x, 450)]

        elif lvl == 2:
            MOVE_SPEED = 3.0 
            
            config["enemies"] = [
                [526, 275, MOVE_SPEED, 0],   
                [574, 275, MOVE_SPEED, 0],   
                [625, 275, 0, MOVE_SPEED],   
                [625, 326, 0, MOVE_SPEED],   
                [625, 374, 0, MOVE_SPEED],   
                [625, 425, -MOVE_SPEED, 0],  
                [574, 425, -MOVE_SPEED, 0],  
                [526, 425, -MOVE_SPEED, 0],  
                [475, 425, 0, -MOVE_SPEED],  
                [475, 374, 0, -MOVE_SPEED]
            ]
            config["player_pos"] = (550-15, 350-15)
            config["finish_rect"] = pygame.Rect(500, 300, 100, 100)
            config["walls_pts"] = [(500,250), (650,250), (650,450), (450,450), (450,200), (500,200)]
            config["coins"] = [[475, 225]]; config["coins_req"] = 1
            # Grid Level 2
            config["grid_cells"] = [(450,250), (450,350), (550,250), (600,300), (500,400), (600,400)]

        elif lvl == 3:
            config["player_pos"] = (550-15, 125-15)
            config["finish_rect"] = pygame.Rect(200, 350, 150, 100)
            config["coins"] = [[550, 250], [700, 400], [550, 550]]; config["coins_req"] = 3
            center = (550, 400)
            for r in [175, 140, 105, 70, 35]:
                for off in [0, 1.6, 3.2, 4.8]: config["enemies"].append([center[0], center[1], r, off])
            config["walls_pts"] = [(500,200), (500,50), (600,50), (600,200), (650,200), (650,250), (700,250), (700,300), (750,300), (750,500), (700,500), (700,550), (650,550), (650,600), (450,600), (450,550), (400,550), (400,500), (350,500), (350,450), (200,450), (200,350), (350,350), (350,300), (400,300), (400,250), (450,250), (450,200)]
            # Grid Level 3 (Checkerboard loops)
            for x in range(500,650,100): config["grid_cells"].append((x,200))
            for x in range(450,700,100): config["grid_cells"].append((x,250))
            for x in range(400,750,100): config["grid_cells"].append((x,300))
            for x in range(350,700,100): config["grid_cells"].append((x,350))
            for x in range(400,750,100): config["grid_cells"].append((x,400))
            for x in range(350,700,100): config["grid_cells"].append((x,450))
            for x in range(400,650,100): config["grid_cells"].append((x,500))
            for x in range(450,600,100): config["grid_cells"].append((x,550))

        elif lvl == 4:
            config["player_pos"] = (150-15, 125-15)
            config["finish_rect"] = pygame.Rect(650, 300, 50, 100)
            config["checkpoints"] = [pygame.Rect(900, 100, 50, 50), pygame.Rect(100, 200, 50, 50)]
            center = (550, 350)
            for r in [375, 275, 175, 75]:
                for off in [0, 1.6, 3.2, 4.8]: config["enemies"].append([center[0], center[1], r, off])
            config["walls_pts"] = [(100,150), (100,100), (950,100), (950,150), (900,150), (900,600), (200,600), (200,250), (100,250), (100,200), (800,200), (800,500), (300,500), (300,300), (700,300), (700,400), (400,400), (400,350), (350,350), (350,450), (750,450), (750,250), (250,250), (250,550), (850,550), (850,150)]
            # Grid Level 4
            for x in range(200,850,100): config["grid_cells"].append((x,100))
            for y in range(150,600,100): config["grid_cells"].append((850,y))
            for x in range(250,800,100): config["grid_cells"].append((x,550))
            for y in range(200,600,100): config["grid_cells"].append((200,y))
            for x in range(300,800,100): config["grid_cells"].append((x,200))
            for y in range(250,500,100): config["grid_cells"].append((750,y))
            for x in range(350,750,100): config["grid_cells"].append((x,450))
            for y in range(300,450,100): config["grid_cells"].append((300,y))
            for x in range(400,650,100): config["grid_cells"].append((x,300))
            for x in range(450,600,100): config["grid_cells"].append((x,350))

        elif lvl == 5:
            config["player_pos"] = (150-15, 150-15)
            config["finish_rect"] = pygame.Rect(100, 500, 100, 100)
            config["checkpoints"] = [pygame.Rect(800, 300, 200, 100)]
            config["coins"] = [[225,425], [425,425], [625,425], [825,425]]
            config["coins_req"] = 4
            config["walls_pts"] = [(100,100), (1000,100), (1000,600), (100,600), (100,500), (200,500), (200,400), (800,400), (800,300), (200,300), (200,200), (100,200)]
            for x in range(200,950,100): config["grid_cells"] += [(x,100), (x,200), (x,400), (x,500)]
            for x in range(250,1000,100): config["grid_cells"] += [(x,150), (x,250), (x,450), (x,550)]
            # Enemies: 8 tâm xoay và các chấm xoay quanh
            centers = [(300,200), (500,200), (700,200), (900,200), (300,500), (500,500), (700,500), (900,500)]
            for cx, cy in centers:
                config["enemies"].append([cx, cy, 0, 0]) # Chấm tâm đứng yên
                for r in [86, 43]:
                    for off in [0, 1.6, 3.2, 4.8]: config["enemies"].append([cx, cy, r, off])

        elif lvl == 6:
            config["player_pos"] = (175-15, 350-15)
            config["finish_rect"] = pygame.Rect(850, 300, 150, 100)
            config["walls_pts"] = [(100,300), (250,300), (250,150), (850,150), (850,300), (1000,300), (1000,400), (850,400), (850,550), (250,550), (250,400), (100,400)]
            config["coins"] = [[275,175], [275,525], [825,175], [825,525]]
            config["coins_req"] = 4
            for x in range(250,850,100): config["grid_cells"] += [(x,150), (x,250), (x,350), (x,450)]
            for x in range(300,850,100): config["grid_cells"] += [(x,200), (x,300), (x,400), (x,500)]
            for i, x in enumerate(range(275, 875, 50)):
                dy = 8 if i % 2 == 0 else -8
                config["enemies"].append([x, 170 if i % 2 == 0 else 530, 0, dy])

        elif lvl == 7:
            config["player_pos"] = (325-15, 175-15)
            config["finish_rect"] = pygame.Rect(750, 300, 100, 100)
            config["walls_pts"] = [(250,100), (450,100), (450,150), (550,150), (550,100), (750,100), (750,300), (850,300), (850,400), (750,400), (750,600), (550,600), (550,550), (450,550), (450,600), (250,600), (250,100)]
            config["coins"] = [[275, 575], [725, 125], [725, 575]]; config["coins_req"] = 3
            # Grid Level 7
            for y in range(150, 650, 100): config["grid_cells"] += [(250, y), (550, y)]
            for y in range(100, 600, 100): config["grid_cells"] += [(400, y), (700, y)]
            for x, y in [(300,100), (350,250), (300,400), (350,550), (450,150), (500,500), (600,100), (650,250), (600,400), (650,550)]:
                config["grid_cells"].append((x, y))
            # Enemies: [x, y, dx, dy]
            config["enemies"] = [[274, 124, 4, 0], [274, 274, 4, 0], [274, 424, 4, 0], [726, 124, -4, 0], [726, 274, -4, 0], [726, 424, -4, 0], [424, 174, 4, 0]]

        elif lvl == 8:
            config["player_pos"] = (150-15, 150-15)
            config["finish_rect"] = pygame.Rect(900, 300, 100, 100)
            config["checkpoints"] = [pygame.Rect(500, 400, 100, 100)]
            config["walls_pts"] = [(100,100), (200,100), (200,200), (300,200), (300,100), (600,100), (600,400), (700,400), (700,100), (1000,100), (1000,400), (900,400), (900,200), (800,200), (800,500), (1000,500), (1000,600), (700,600), (700,500), (400,500), (400,600), (100,600), (100,100)]
            config["coins"] = [[950, 550]]; config["coins_req"] = 1
            # Grid Level 8
            for y in range(200, 600, 100): config["grid_cells"] += [(100, y), (700, y)]
            for y in range(250, 650, 100): config["grid_cells"] += [(150, y), (750, y)]
            for y in range(100, 400, 100): config["grid_cells"] += [(500, y)]
            for y in range(150, 450, 100): config["grid_cells"] += [(550, y)]
            for x, y in [(200,200), (250,250), (300,200), (350,250), (300,100), (350,150), (400,100), (450,150), (200,500), (250,550), (300,500), (350,550), (300,400), (350,450), (400,400), (450,450), (600,400), (650,450), (800,100), (850,150), (900,100), (950,150), (900,200), (950,250), (800,500), (850,550), (900,500), (950,550)]:
                config["grid_cells"].append((x, y))
            # Enemies: Static + Moving
            statics = [[250,225], [325,150], [450,175], [525,250], [175,350], [125,450], [250,525], [325,450], [400,425], [475,475], [725,550], [725,350], [775,250], [850,175], [925,250]]
            config["enemies"] = [[s[0], s[1], 0, 0] for s in statics]
            config["enemies"] += [[125,225,5,0], [375,275,-5,0], [575,175,-5,0], [175,575,-5,0], [375,575,-5,0], [725,425,5,0], [725,125,5,0], [975,175,-5,0], [525,376,5,0], [901,575,0,-5]]

        elif lvl == 9:
            config["player_pos"] = (475-15, 150-15)
            config["finish_rect"] = pygame.Rect(600, 100, 150, 100)
            config["walls_pts"] = [(400,100), (550,100), (550,200), (450,200), (450,250), (500,250), (500,450), (400,450), (400,500), (650,500), (650,450), (550,450), (550,250), (600,250), (600,100), (750,100), (750,200), (650,200), (650,400), (750,400), (750,550), (650,550), (650,600), (400,600), (400,550), (300,550), (300,400), (400,400)]
            config["coins_req"] = 0
            # Grid Level 9
            for x in range(300, 800, 100): config["grid_cells"].append((x, 500))
            for x, y in [(400,200), (450,250), (400,300), (450,350), (400,400), (300,400), (350,450), (450,550), (550,550), (650,450), (700,400), (600,400), (550,350), (600,300), (550,250), (600,200)]:
                config["grid_cells"].append((x, y))
            config["enemies"] = [[486,275,-2,0], [486,375,-2,0], [386,475,-2,0], [736,525,-2,0], [736,425,-2,0], [636,425,-2,0], [636,325,-2,0], [414,325,2,0], [414,425,2,0], [314,425,2,0], [314,525,2,0], [664,475,2,0], [564,375,2,0], [564,275,2,0], [425,514,0,2], [525,514,0,2], [625,514,0,2], [475,586,0,-2], [575,586,0,-2]]

        elif lvl == 10:
            config["player_pos"] = (900-15, 300-15)
            config["finish_rect"] = pygame.Rect(150, 350, 100, 100)
            config["walls_pts"] = [(350,150), (950,150), (950,350), (850,350), (850,200), (750,200), (750,550), (150,550), (150,350), (250,350), (250,500), (350,500), (350,150)]
            config["coins"] = [[375, 175], [725, 525]]; config["coins_req"] = 2
            # Grid Level 10
            for x in range(350, 950, 100): config["grid_cells"].append((x, 150))
            for x in range(400, 800, 100): config["grid_cells"].append((x, 200))
            for x in range(350, 750, 100): config["grid_cells"].append((x, 250))
            for x in range(400, 800, 100): config["grid_cells"].append((x, 300))
            for x in range(350, 750, 100): config["grid_cells"].append((x, 350))
            for x in range(400, 800, 100): config["grid_cells"].append((x, 400))
            for x in range(350, 750, 100): config["grid_cells"].append((x, 450))
            for x in range(200, 800, 100): config["grid_cells"].append((x, 500))
            config["grid_cells"] += [(150, 450), (900, 200)]
            # Enemies
            center = (550, 350)
            for r in [250, 215, 180, 145, 110, 75, 40]:
                for off in [0, 1.6, 3.2, 4.8]: config["enemies"].append([center[0], center[1], r, off])
        return config

----------------------------------------

--- File: main.py ---
import pygame
import sys
from settings import *
from sprites import Player, Enemy, Coin
from level_manager import LevelManager

class Game:
    def __init__(self, start_level=0):
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("The World's Hardest Game - Python")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Arial", 22, bold=True)
        
        self.lvl = start_level
        self.deaths = 0
        self.angle = 0
        self.checkpoint_pos = None
        self.load_level()

    def load_level(self):
        data = LevelManager.get_config(self.lvl)
        # Hệ thống checkpoint
        if self.checkpoint_pos is None:
            self.checkpoint_pos = data["player_pos"]
            
        self.player = Player(*self.checkpoint_pos)
        self.enemies = [Enemy(e, self.lvl) for e in data["enemies"]]
        self.coins = [Coin(c[0], c[1]) for c in data["coins"]]
        self.finish_rect = data["finish_rect"]
        self.checkpoints = data.get("checkpoints", [])
        self.walls_pts = data["walls_pts"]
        self.grid_cells = data["grid_cells"]
        self.coins_req = data["coins_req"]
        self.current_coins = 0
        
        # Tạo mask tường để va chạm pixel
        surf = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        if self.walls_pts:
            pygame.draw.polygon(surf, BLACK, self.walls_pts, WALL_WIDTH)
        self.wall_mask = pygame.mask.from_surface(surf)

    def update(self):
        keys = pygame.key.get_pressed()
        dx = (keys[pygame.K_RIGHT] - keys[pygame.K_LEFT]) * PLAYER_SPEED
        dy = (keys[pygame.K_DOWN] - keys[pygame.K_UP]) * PLAYER_SPEED
        if dx != 0 or dy != 0: self.player.move(dx, dy, self.wall_mask)

        # Cập nhật enemy và check chết
        self.angle += 0.03
        player_center = pygame.Vector2(self.player.rect.center)
        for en in self.enemies:
            en.update(self.angle)
            enemy_pos = pygame.Vector2(en.x, en.y)
            distance = player_center.distance_to(enemy_pos)
            
            # Va chạm xảy ra khi khoảng cách nhỏ hơn (bán kính kẻ thù + nửa cạnh người chơi)
            # Bán kính kẻ thù là ENEMY_RADIUS (10), nửa cạnh người chơi là PLAYER_SIZE/2 (15)
            if distance < (ENEMY_RADIUS + PLAYER_SIZE / 2):
                self.deaths += 1
                self.load_level()
                return
        # Check ăn coin
        for c in self.coins[:]:
            coin_pos = pygame.Vector2(c.pos)
            distance = player_center.distance_to(coin_pos)
            
            # Bán kính coin là 10, nửa cạnh người chơi là 15
            if distance < (10 + PLAYER_SIZE / 2):
                self.coins.remove(c)
                self.current_coins += 1

        # Check checkpoint
        for cp in self.checkpoints:
            if cp.colliderect(self.player.rect):
                new_cp = (cp.x + (cp.width-PLAYER_SIZE)//2, cp.y + (cp.height-PLAYER_SIZE)//2)
                if self.checkpoint_pos != new_cp:
                    self.checkpoint_pos = new_cp

        # Check về đích
        if self.finish_rect.colliderect(self.player.rect) and self.current_coins >= self.coins_req:
            self.lvl += 1
            self.checkpoint_pos = None
            self.load_level()

    def draw(self):
        # Màu nền thay đổi theo độ khó
        color = BG_L_BLUE if self.lvl < 19 else BG_PURPLE
        self.screen.fill(color)

        # 1. Vẽ vùng đặc biệt (Start/Checkpoint/Finish)
        if self.lvl == 0: pygame.draw.rect(self.screen, RED, (100, 200, 150, 300))
        elif self.lvl == 1: pygame.draw.rect(self.screen, RED, (100, 300, 150, 100))
        for cp in self.checkpoints: pygame.draw.rect(self.screen, GREEN_CHECKPOINT, cp)
        pygame.draw.rect(self.screen, GREEN_FINISH, self.finish_rect)

        # 2. VẼ Ô LƯỚI (GRID) - Vẽ trước tường để không đè lên viền
        for cell in self.grid_cells:
            pygame.draw.rect(self.screen, WHITE, (cell[0], cell[1], 50, 50))

        # 3. Vẽ Tường
        if self.walls_pts:
            pygame.draw.polygon(self.screen, BLACK, self.walls_pts, WALL_WIDTH)

        # 4. Vẽ Entities
        for c in self.coins: c.draw(self.screen)
        for en in self.enemies: en.draw(self.screen)
        self.player.draw(self.screen)
        
        # 5. Vẽ UI
        pygame.draw.rect(self.screen, BLACK, (0, 0, WIDTH, 40))
        ui_txt = f"LEVEL: {self.lvl + 1} / 30    COINS: {self.current_coins}/{self.coins_req}    DEATHS: {self.deaths:04}"
        self.screen.blit(self.font.render(ui_txt, True, WHITE), (20, 8))
        
        pygame.display.flip()

    def run(self):
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT: pygame.quit(); sys.exit()
            self.update(); self.draw()
            self.clock.tick(FPS)

if __name__ == "__main__":
    # Thay đổi level bắt đầu ở đây
    game = Game(start_level=0) 
    game.run()

----------------------------------------

--- File: replay.py ---
import pygame
import json
import sys
import os
from settings import *
from sprites import Player, Enemy
from level_manager import LevelManager

class ReplayVisualizer:
    def __init__(self, level_to_replay):
        pygame.init()
        self.level = level_to_replay
        self.config = LevelManager.get_config(self.level)
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption(f"Replay Level {self.level} - The Best DNA")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Arial", 20, bold=True)

        # 1. Tải dữ liệu từ archivement.txt
        self.record_data = self.load_record()
        if not self.record_data:
            print(f"Error: Không tìm thấy dữ liệu replay cho Level {self.level} trong archivement.txt")
            pygame.quit()
            sys.exit()

        self.best_dna = self.record_data["dna"]
        self.dna_length = len(self.best_dna)
        self.pop_size = self.record_data.get("pop_size", 100) # Số lượng cá thể hiển thị

        # 2. Tạo Mask tường để xử lý va chạm
        surf = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        if self.config["walls_pts"]:
            pygame.draw.polygon(surf, BLACK, self.config["walls_pts"], WALL_WIDTH)
        self.wall_mask = pygame.mask.from_surface(surf)

        # 3. Khởi tạo thực thể
        self.players = [Player(*self.config["player_pos"]) for _ in range(self.pop_size)]
        self.enemies = [Enemy(e, self.level) for e in self.config["enemies"]]
        
        # Coins (Chỉ để hiển thị cho giống môi trường train)
        self.coins_pos = []
        if self.level == 0: self.coins_pos = [(325, 475), (775, 225)]
        elif self.level == 1: self.coins_pos = [(550, 350), (825, 350)]
        elif self.level == 2: self.coins_pos = [(475, 225)]
        elif self.level == 3: self.coins_pos = [(550, 250), (625, 325), (700, 400), (625, 475), (550, 550), (375, 425)]

        self.current_frame = 0
        self.angle = 0
        self.finished = False

    def load_record(self):
        file_path = "archivement.txt"
        if not os.path.exists(file_path):
            return None
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                return data.get(str(self.level))
        except Exception as e:
            print(f"Lỗi đọc file: {e}")
            return None

    def run(self):
        running = True
        while running:
            self.screen.fill(BG_L_BLUE)

            # --- Vẽ Môi Trường ---
            pygame.draw.rect(self.screen, GREEN_FINISH, self.config["finish_rect"])
            for cell in self.config["grid_cells"]:
                pygame.draw.rect(self.screen, WHITE, (cell[0], cell[1], 50, 50))
            if self.config["walls_pts"]:
                pygame.draw.polygon(self.screen, BLACK, self.config["walls_pts"], WALL_WIDTH)
            for pos in self.coins_pos:
                pygame.draw.circle(self.screen, YELLOW_COIN, pos, 10)
                pygame.draw.circle(self.screen, BLACK, pos, 10, 2)

            # --- Cập nhật logic ---
            self.angle += 0.03
            for en in self.enemies: en.update(self.angle)

            if self.current_frame < self.dna_length:
                dx, dy = self.best_dna[self.current_frame]
                
                # Cập nhật tất cả player chạy cùng 1 bộ DNA
                for p in self.players:
                    p.move(dx, dy, self.wall_mask)
                self.current_frame += 1
            else:
                self.finished = True

            # --- Vẽ Thực Thể ---
            for en in self.enemies: en.draw(self.screen)
            for p in self.players:
                # Vẽ màu xanh cho khác với lúc train (màu đỏ)
                pygame.draw.rect(self.screen, (0, 150, 255), p.rect)
                pygame.draw.rect(self.screen, BLACK, p.rect, 1)

            # --- UI ---
            status = "REPLAYING..." if not self.finished else "FINISHED (Looping)"
            ui_text = [
                f"LEVEL: {self.level}",
                f"STATUS: {status}",
                f"FRAME: {self.current_frame}/{self.dna_length}",
                f"FITNESS: {self.record_data['fitness']:.2f}",
                f"WON AT GEN: {self.record_data['gen']}"
            ]
            
            for i, text in enumerate(ui_text):
                img = self.font.render(text, True, BLACK)
                self.screen.blit(img, (20, 20 + i * 25))

            # Nếu chạy hết DNA thì tự động reset để xem lại
            if self.finished:
                pygame.time.delay(1000) # Đợi 1 giây trước khi reset
                self.current_frame = 0
                self.angle = 0
                self.finished = False
                self.players = [Player(*self.config["player_pos"]) for _ in range(self.pop_size)]

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            pygame.display.flip()
            self.clock.tick(60) # Replay ở tốc độ 60 FPS cho mượt

        pygame.quit()

if __name__ == "__main__":
    # Thay đổi level bạn muốn xem lại ở đây
    LEVEL_TO_WATCH = 0
    
    replay = ReplayVisualizer(level_to_replay=LEVEL_TO_WATCH)
    replay.run()

----------------------------------------

--- File: settings.py ---
import pygame

WIDTH, HEIGHT = 1100, 700
FPS = 60
PLAYER_SIZE = 30
PLAYER_SPEED = 3
ENEMY_RADIUS = 10
WALL_WIDTH = 5

# Colors
BG_L_BLUE = (128, 128, 255)
BG_PURPLE = (223, 128, 255)
BG_RED = (255, 128, 128)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN_FINISH = (0, 128, 0)
GREEN_CHECKPOINT = (0, 230, 0)
YELLOW_COIN = (255, 255, 0)
BLUE_ENEMY = (0, 0, 255)

----------------------------------------

--- File: sprites.py ---
import pygame
import math
from settings import *

class Player:
    def __init__(self, x, y):
        self.rect = pygame.Rect(x, y, PLAYER_SIZE, PLAYER_SIZE)
        
    def move(self, dx, dy, wall_mask):
        # --- XỬ LÝ TRỤC X ---
        old_x = self.rect.x
        self.rect.x += dx
        # Tạo mask tạm thời cho Player để kiểm tra va chạm
        player_mask = pygame.mask.Mask((PLAYER_SIZE, PLAYER_SIZE), fill=True)
        
        if wall_mask.overlap(player_mask, (self.rect.x, self.rect.y)):
            self.rect.x = old_x 
            step = 1 if dx > 0 else -1
            # Nhích từng pixel để sát tường nhất có thể
            for _ in range(int(abs(dx))):
                self.rect.x += step
                if wall_mask.overlap(player_mask, (self.rect.x, self.rect.y)):
                    self.rect.x -= step
                    break

        # --- XỬ LÝ TRỤC Y ---
        old_y = self.rect.y
        self.rect.y += dy
        if wall_mask.overlap(player_mask, (self.rect.x, self.rect.y)):
            self.rect.y = old_y
            step = 1 if dy > 0 else -1
            # Nhích từng pixel để sát tường nhất có thể
            for _ in range(int(abs(dy))):
                self.rect.y += step
                if wall_mask.overlap(player_mask, (self.rect.x, self.rect.y)):
                    self.rect.y -= step
                    break

    def draw(self, surface):
        pygame.draw.rect(surface, RED, self.rect)
        pygame.draw.rect(surface, BLACK, self.rect, 2)

class Enemy:
    def __init__(self, data, lvl):
        self.lvl = lvl
        self.x = float(data[0])
        self.y = float(data[1])
        self.start_x, self.start_y = self.x, self.y
        self.radius = data[2]
        self.angle_offset = data[3]
        self.dx = float(data[2]) 
        self.dy = float(data[3])
        self.speed_rot = 1.0 # Riêng cho level 10

    def update(self, angle):
        if self.lvl in [0, 1, 6]: # Linear đơn giản
            self.x += self.dx
            self.y += self.dy
            if self.lvl == 0:
                if self.x <= 325 or self.x >= 775: self.dx *= -1
            elif self.lvl == 1:
                if self.y <= 226 or self.y >= 474: self.dy *= -1
            elif self.lvl == 6:
                if self.y <= 170 or self.y >= 530: self.dy *= -1
        
        elif self.lvl == 2:
            self.x += self.dx
            self.y += self.dy
            
            # Sử dụng giá trị tuyệt đối của tốc độ hiện tại để gán cho hướng mới
            # giúp bạn chỉ cần chỉnh ở LevelManager là toàn bộ logic sẽ chạy theo
            speed = max(abs(self.dx), abs(self.dy))
            
            # Kiểm tra va chạm các góc với sai số nhỏ (tốc độ càng cao sai số càng cần lớn)
            # Ở đây dùng abs(self.x - góc) < speed để đảm bảo luôn bắt được điểm quay đầu
            if abs(self.x - 475) < speed and abs(self.y - 275) < speed:
                self.dx, self.dy = speed, 0
            elif abs(self.x - 625) < speed and abs(self.y - 275) < speed:
                self.dx, self.dy = 0, speed
            elif abs(self.x - 625) < speed and abs(self.y - 425) < speed:
                self.dx, self.dy = -speed, 0
            elif abs(self.x - 475) < speed and abs(self.y - 425) < speed:
                self.dx, self.dy = 0, -speed
        
        elif self.lvl == 7: # Path movement (Chạy quanh ô vuông)
            self.x += self.dx
            self.y += self.dy
            cx, cy = round(self.x), round(self.y)
            if cx in [426, 574, 576] and cy in [124, 174, 274, 424]: self.dx, self.dy = 0, 4
            elif cx == 426 and cy in [276, 426, 576]: self.dx, self.dy = -4, 0
            elif cx == 574 and cy in [276, 426, 576]: self.dx, self.dy = 4, 0
            elif cx in [274, 424, 726] and cy in [276, 426, 526, 576]: self.dx, self.dy = 0, -4
            elif cx == 274 and cy in [124, 274, 424]: self.dx, self.dy = 4, 0
            elif cx == 726 and cy in [124, 274, 424]: self.dx, self.dy = -4, 0

        elif self.lvl == 8: # Logic đổi hướng tại các biên
            if self.dx != 0 or self.dy != 0:
                self.x += self.dx
                self.y += self.dy
                cx, cy = round(self.x), round(self.y)
                if cx in [175, 375, 575, 775, 975] and cy in [125, 225, 425, 525]: self.dx, self.dy = 0, 5
                elif cx in [175, 375, 575, 775, 975] and cy in [175, 275, 475, 575]: self.dx, self.dy = -5, 0
                elif cx in [125, 325, 525, 725, 925] and cy in [175, 275, 475, 575]: self.dx, self.dy = 0, -5
                elif cx in [125, 325, 525, 725, 925] and cy in [125, 225, 425, 525]: self.dx, self.dy = 5, 0

        elif self.lvl == 9: # Linear va chạm biên
            self.x += self.dx
            self.y += self.dy
            if self.dx != 0:
                if self.x <= 314 or self.x >= 736: self.dx *= -1
            if self.dy != 0:
                if self.y <= 514 or self.y >= 586: self.dy *= -1

        elif self.lvl == 10: # Orbital tăng tốc
            self.speed_rot = min(self.speed_rot + 0.0001, 0.05) # Giả lập tăng tốc độ xoay
            # Sử dụng góc tích lũy riêng để không bị giật
            new_angle = angle * self.speed_rot * 40 
            self.x = self.start_x + self.radius * math.cos(new_angle + self.angle_offset)
            self.y = self.start_y + self.radius * math.sin(new_angle + self.angle_offset)
            
        else: # Orbital mặc định (3, 4, 5)
            self.x = self.start_x + self.radius * math.cos(angle + self.angle_offset)
            self.y = self.start_y + self.radius * math.sin(angle + self.angle_offset)

    def draw(self, surface):
        pygame.draw.circle(surface, BLUE_ENEMY, (int(self.x), int(self.y)), ENEMY_RADIUS)
        pygame.draw.circle(surface, BLACK, (int(self.x), int(self.y)), ENEMY_RADIUS, 2)

class Coin:
    def __init__(self, x, y):
        self.rect = pygame.Rect(x-15, y-15, 30, 30)
        self.pos = (x, y)
    def draw(self, surface):
        pygame.draw.circle(surface, YELLOW_COIN, self.pos, 10)
        pygame.draw.circle(surface, BLACK, self.pos, 10, 2)

----------------------------------------

--- File: test.py ---
import os
import argparse
import tkinter as tk
from tkinter import filedialog

INPUT_PATH = os.getcwd()
OUTPUT_PATH = os.path.join(os.getcwd(), "summary.txt")

DEFAULT_IGNORE_DIRS = {'.git', '_pycache_', 'venv', '.vscode', '.idea', 'node_modules', 'build', 'dist'}
DEFAULT_IGNORE_FILES = {'.DS_Store'}
DEFAULT_IGNORE_EXTENSIONS = {'.pyc', '.log', '.tmp', '.bak', '.swp'}

def generate_project_summary(input_path=INPUT_PATH, output_path=OUTPUT_PATH):
    if not input_path or not os.path.isdir(input_path):
        print(f"Error: Invalid path '{input_path}'")
        return

    project_structure = []
    python_files_content = []
    yaml_files_content = []

    abs_project_path = os.path.abspath(input_path)
    project_root_name = os.path.basename(abs_project_path)

    for dirpath, dirnames, filenames in os.walk(abs_project_path, topdown=True):
        dirnames[:] = [d for d in dirnames if d not in DEFAULT_IGNORE_DIRS]

        relative_dir = os.path.relpath(dirpath, abs_project_path)
        level = relative_dir.count(os.sep) if relative_dir != '.' else 0
        indent = '    ' * level + '|-- '

        if relative_dir == '.':
            project_structure.append(f"{project_root_name}/")
        else:
            if not any(ignored in relative_dir.split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                project_structure.append(f"{indent}{os.path.basename(dirpath)}/")

        sub_indent = '    ' * (level + 1) + '|-- '
        dirnames.sort()
        filenames.sort()

        for filename in filenames:
            if filename in DEFAULT_IGNORE_FILES:
                continue
            if os.path.splitext(filename)[1] in DEFAULT_IGNORE_EXTENSIONS:
                continue

            if not any(ignored in os.path.join(relative_dir, filename).split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                project_structure.append(f"{sub_indent}{filename}")

            if filename.endswith(('.py', '.yaml')):
                file_path = os.path.join(dirpath, filename)
                relative_file_path = os.path.relpath(file_path, abs_project_path)

                if not any(ignored in relative_file_path.split(os.sep) for ignored in DEFAULT_IGNORE_DIRS):
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()

                        if filename.endswith('.py'):
                            python_files_content.append((relative_file_path, content))
                        elif filename.endswith('.yaml'):
                            yaml_files_content.append((relative_file_path, content))

                    except Exception as e:
                        if filename.endswith('.py'):
                            python_files_content.append((relative_file_path, f"Error reading file: {e}"))
                        elif filename.endswith('.yaml'):
                            yaml_files_content.append((relative_file_path, f"Error reading file: {e}"))

    try:
        with open(output_path, 'w', encoding='utf-8') as outfile:
            outfile.write("=========================================\n")
            outfile.write(" PROJECT DIRECTORY STRUCTURE\n")
            outfile.write("=========================================\n\n")
            outfile.write(f"Root directory: {abs_project_path}\n\n")
            outfile.write('\n'.join(project_structure))
            outfile.write("\n\n=========================================\n")
            outfile.write(" PYTHON FILES CONTENT (.py)\n")
            outfile.write("=========================================\n\n")

            python_files_content.sort(key=lambda item: item[0])

            for rel_path, content in python_files_content:
                outfile.write(f"--- File: {rel_path} ---\n")
                outfile.write(content)
                outfile.write("\n\n----------------------------------------\n\n")

            if yaml_files_content:
                outfile.write("\n\n=========================================\n")
                outfile.write(" YAML FILES CONTENT (.yaml)\n")
                outfile.write("=========================================\n\n")

                yaml_files_content.sort(key=lambda item: item[0])
                for rel_path, content in yaml_files_content:
                    outfile.write(f"--- File: {rel_path} ---\n")
                    outfile.write(content)
                    outfile.write("\n\n----------------------------------------\n\n")

    except Exception as e:
        print(f"Error writing output file: {e}")

if __name__ == "__main__":
    generate_project_summary()

----------------------------------------

--- File: train.py ---
import pygame
import random
import math
import json
import sys
import os
from settings import *
from sprites import Player, Enemy
from level_manager import LevelManager

# --- Cấu hình Giải thuật Di truyền ---
POPULATION_SIZE = 1000
GENES_PER_STEP = 400 
MUTATION_RATE = 0.05
ELITISM_COUNT = 10
DNA_INCREASE_RATE = 50  # Tăng DNA sau mỗi 10 thế hệ

class Genome:
    def __init__(self, length):
        self.genes = []
        last_gene = None
        for _ in range(length):
            # 10% cơ hội đổi hướng để di chuyển mượt hơn 
            if last_gene is None or random.random() < 0.1:
                angle = random.uniform(0, 2 * math.pi)
                last_gene = (math.cos(angle) * PLAYER_SPEED, math.sin(angle) * PLAYER_SPEED)
            self.genes.append(last_gene)
            
        self.fitness = 0
        self.is_dead = False
        self.reached_finish = False
        self.current_step = 0
        self.coins_collected = 0  

class TrainVisualizer:
    def __init__(self, level):
        pygame.init()
        self.level = level
        self.config = LevelManager.get_config(level)
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption(f"AI Trainer Level {level} - Sequential Logic")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Arial", 18, bold=True)
        self.num_font = pygame.font.SysFont("Arial", 14, bold=True)

        surf = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        if self.config["walls_pts"]:
            pygame.draw.polygon(surf, BLACK, self.config["walls_pts"], WALL_WIDTH) 
        self.wall_mask = pygame.mask.from_surface(surf) 

        self.custom_coins = []
        if level == 0:
            self.custom_coins = [
                {"pos": (325, 475), "type": "RED"},    
                {"pos": (775, 225), "type": "RED"}
            ]
        elif level == 1:
            self.custom_coins = [
                {"pos": (550, 350), "type": "YELLOW"},
                {"pos": (825, 350), "type": "RED"}
            ]
        elif level == 2:
            self.custom_coins = [
                {"pos": (475, 225), "type": "YELLOW"}
            ]
        elif level == 3:
            self.custom_coins = [
                {"pos": (550, 250), "type": "YELLOW"},
                {"pos": (625, 325), "type": "RED"},
                {"pos": (700, 400), "type": "YELLOW"},
                {"pos": (625, 475), "type": "RED"},
                {"pos": (550, 550), "type": "YELLOW"},
                {"pos": (375, 425), "type": "RED"}
            ]
        self.target_pos = pygame.Vector2(self.config["finish_rect"].center)
        self.finished = False
        self.generation = 0
        self.setup_generation()

    def setup_generation(self):
        global GENES_PER_STEP
        
        # Tăng DNA sau mỗi 10 thế hệ
        if self.generation > 0 and self.generation % 10 == 0:
            GENES_PER_STEP += DNA_INCREASE_RATE
            print(f"--- Gen {self.generation}: DNA increased to {GENES_PER_STEP} ---")
            
            # Bù đắp gene cho quần thể hiện tại
            for genome in self.population:
                while len(genome.genes) < GENES_PER_STEP:
                    last_gene = genome.genes[-1] if genome.genes else None
                    if last_gene is None or random.random() < 0.1:
                        angle = random.uniform(0, 2 * math.pi)
                        last_gene = (math.cos(angle) * PLAYER_SPEED, math.sin(angle) * PLAYER_SPEED)
                    genome.genes.append(last_gene)

        if self.generation == 0:
            self.population = [Genome(GENES_PER_STEP) for _ in range(POPULATION_SIZE)]
        
        self.players = [Player(*self.config["player_pos"]) for _ in range(POPULATION_SIZE)]
        self.enemies = [Enemy(e, self.level) for e in self.config["enemies"]]
        self.current_frame = 0
        self.angle = 0
        self.generation += 1

    def run(self):
        running = True
        while running:
            self.screen.fill(BG_L_BLUE)
            
            # Vẽ Map
            pygame.draw.rect(self.screen, GREEN_FINISH, self.config["finish_rect"])
            for cell in self.config["grid_cells"]:
                pygame.draw.rect(self.screen, WHITE, (cell[0], cell[1], 50, 50))
            if self.config["walls_pts"]:
                pygame.draw.polygon(self.screen, BLACK, self.config["walls_pts"], WALL_WIDTH)

            # Vẽ Coin
            for i, c_data in enumerate(self.custom_coins):
                color = RED if c_data["type"] == "RED" else YELLOW_COIN
                pygame.draw.circle(self.screen, color, c_data["pos"], 10)
                pygame.draw.circle(self.screen, BLACK, c_data["pos"], 10, 2)
                lbl = self.num_font.render(str(i+1), True, BLACK)
                self.screen.blit(lbl, (c_data["pos"][0]-5, c_data["pos"][1]-25))

            active_players = False
            self.angle += 0.025
            for en in self.enemies: en.update(self.angle)

            for i in range(POPULATION_SIZE):
                genome = self.population[i]
                player = self.players[i]

                if not genome.is_dead and not genome.reached_finish:
                    active_players = True
                    if self.current_frame < len(genome.genes):
                        dx, dy = genome.genes[self.current_frame]
                        player.move(dx, dy, self.wall_mask)

                    player_center = pygame.Vector2(player.rect.center)

                    # Check va chạm kẻ địch
                    for en in self.enemies:
                        enemy_pos = pygame.Vector2(en.x, en.y)
                        if player_center.distance_to(enemy_pos) < (ENEMY_RADIUS + PLAYER_SIZE / 2):
                            genome.is_dead = True
                            genome.current_step = self.current_frame

                    # Check ăn Coin tuần tự
                    if genome.coins_collected < len(self.custom_coins):
                        c_pos = pygame.Vector2(self.custom_coins[genome.coins_collected]["pos"])
                        if player_center.distance_to(c_pos) < (10 + PLAYER_SIZE / 2):
                            genome.coins_collected += 1

                    # Check Win: CHỈ thắng khi ăn hết coin VÀ chạm đích
                    if genome.coins_collected == len(self.custom_coins):
                        if player.rect.colliderect(self.config["finish_rect"]):
                            # Ở Level 2 (spawn tại đích), cần di chuyển ít nhất vài bước mới tính thắng
                            if self.current_frame > 5:
                                genome.reached_finish = True
                                genome.current_step = self.current_frame
                                self.finished = True

                p_color = RED if not genome.is_dead else (100, 100, 100)
                pygame.draw.rect(self.screen, p_color, player.rect)
                pygame.draw.rect(self.screen, BLACK, player.rect, 1)

            for en in self.enemies: en.draw(self.screen) 

            ui = f"GEN: {self.generation} | DNA: {GENES_PER_STEP} | BEST COINS: {max(g.coins_collected for g in self.population)}"
            self.screen.blit(self.font.render(ui, True, BLACK), (20, 10))
            
            self.current_frame += 1
            if self.current_frame >= GENES_PER_STEP or not active_players:
                self.evolve() # Tính fitness và tạo thế hệ mới
                
                if self.finished:
                    # Nếu có người thắng trong thế hệ này, tìm người tốt nhất và lưu
                    best_genome = max(self.population, key=lambda g: g.fitness)
                    self.save_achievement(best_genome)
                    print(f"CONGRATULATIONS! Level {self.level} cleared. Training stopped.")
                    running = False # Thoát vòng lặp chính
                else:
                    self.setup_generation()

            for event in pygame.event.get():
                if event.type == pygame.QUIT: running = False

            pygame.display.flip()
            self.clock.tick(120)
        pygame.quit()


    def calculate_fitness(self, genome, player):
        # Thưởng theo số coin đã ăn
        fitness = genome.coins_collected * 2000
        
        # Xác định Target hiện tại
        if genome.coins_collected < len(self.custom_coins):
            # Nếu chưa ăn hết coin, target là coin tiếp theo
            target = pygame.Vector2(self.custom_coins[genome.coins_collected]["pos"])
            dist = pygame.Vector2(player.rect.center).distance_to(target)
            fitness += (1 / (dist + 1)) * 1000
            
            # Phạt nếu chạm đích khi chưa ăn đủ coin (đặc biệt cho Level 2)
            if player.rect.colliderect(self.config["finish_rect"]):
                fitness *= 0.5
        else:
            # Nếu đã ăn hết coin, target mới là Đích
            target = self.target_pos
            dist = pygame.Vector2(player.rect.center).distance_to(target)
            fitness += (1 / (dist + 1)) * 1000
        
        if genome.reached_finish:
            fitness += (GENES_PER_STEP - genome.current_step) + 5000

        if genome.is_dead:
            fitness *= 0.9 
            
        return fitness

    def evolve(self):
        cnt = 0
        # Đột biến nhẹ các bước cuối của cá thể chết để tìm hướng thoát
        for genome in self.population:
            if genome.is_dead:
                start_mutate = max(0, genome.current_step - 10)
                for j in range(start_mutate, genome.current_step):
                    angle = random.uniform(0, 2 * math.pi)
                    genome.genes[j] = (math.cos(angle) * PLAYER_SPEED, math.sin(angle) * PLAYER_SPEED)

        for i in range(POPULATION_SIZE):
            self.population[i].fitness = self.calculate_fitness(self.population[i], self.players[i])
        
        self.population.sort(key=lambda x: x.fitness, reverse=True)
        new_pop = []
        
        # Elitism
        for i in range(ELITISM_COUNT):
            elite = self.population[i]
            while len(elite.genes) < GENES_PER_STEP:
                last_gene = elite.genes[-1] if elite.genes else None
                if last_gene is None or random.random() < 0.1:
                    angle = random.uniform(0, 2 * math.pi)
                    last_gene = (math.cos(angle) * PLAYER_SPEED, math.sin(angle) * PLAYER_SPEED)
                elite.genes.append(last_gene)
            new_pop.append(elite)
        # Crossover & Mutation
        while len(new_pop) < POPULATION_SIZE:
            p1, p2 = random.choice(self.population[:10]), random.choice(self.population[:10])
            child = Genome(GENES_PER_STEP)
            cp = random.randint(0, len(p1.genes))
            child_dna = p1.genes[:cp] + p2.genes[cp:]
            
            while len(child_dna) < GENES_PER_STEP:
                last_gene = child_dna[-1] if child_dna else None
                if last_gene is None or random.random() < 0.1:
                    angle = random.uniform(0, 2 * math.pi)
                    last_gene = (math.cos(angle) * PLAYER_SPEED, math.sin(angle) * PLAYER_SPEED)
                child_dna.append(last_gene)
            if cnt < POPULATION_SIZE * 0.2:
                for j in range(len(child_dna)):
                    if random.random() < MUTATION_RATE:
                        angle = random.uniform(0, 2 * math.pi)
                        child_dna[j] = (math.cos(angle) * PLAYER_SPEED, math.sin(angle) * PLAYER_SPEED)
            cnt = cnt + 1   
            child.genes = child_dna
            new_pop.append(child)
            
        self.population = new_pop

    def save_achievement(self, best_genome):
        file_path = "archivement.txt"
        achievements = {}

        # 1. Đọc dữ liệu cũ nếu file tồn tại
        if os.path.exists(file_path):
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    achievements = json.load(f)
            except:
                achievements = {}

        # 2. Chuẩn bị dữ liệu mới
        new_data = {
            "level": self.level,
            "generation": self.generation,
            "population_size": POPULATION_SIZE,
            "dna_length": len(best_genome.genes),
            "fitness": best_genome.fitness,
            "dna": best_genome.genes # Lưu list các tuple (dx, dy)
        }

        # 3. Kiểm tra level đã tồn tại chưa
        lvl_key = str(self.level)
        if lvl_key in achievements:
            if best_genome.fitness > achievements[lvl_key]["fitness"]:
                achievements[lvl_key] = new_data
                print(f"Updated Level {self.level} with higher fitness: {best_genome.fitness}")
            else:
                print(f"Level {self.level} already has a better record. Skipping save.")
        else:
            achievements[lvl_key] = new_data
            print(f"Saved new record for Level {self.level}")

        # 4. Ghi lại vào file (dùng định dạng JSON để dễ đọc/ghi DNA)
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(achievements, f, indent=4)

if __name__ == "__main__":
    # Bắt đầu huấn luyện (Thay đổi level tại đây)
    trainer = TrainVisualizer(level=0)
    trainer.run()

----------------------------------------

